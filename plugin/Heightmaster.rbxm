<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX6883E120DA4646E8800E316D4D588614">
		<Properties>
			<string name="Name">Heightmaster</string>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXCAEDF02BD9A043D4BD78320F0473643F">
			<Properties>
				<string name="Name">Modules</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX6BE1837ED03E4EAA91B8CA3B9B031CAD">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ImporterApp</string>
					<string name="ScriptGuid">{B9F1B961-975D-4BAE-A89B-182E174E4536}</string>
					<ProtectedString name="Source"><![CDATA[-- Modules
local root = script.Parent.Parent
local modules = script.Parent
local roact = root:WaitForChild("Roact")

local SETTINGS = require(modules:WaitForChild("SETTINGS"))

local PNGFolder = script.Parent:WaitForChild("PNG")
local PNG = require(PNGFolder:WaitForChild("PNG"))


local Roact = require(roact:WaitForChild("Roact"))
local Libs = require(roact:WaitForChild("Libs"):WaitForChild("init"))
local ExtraLibs = require(roact:WaitForChild("ExtraLibs"):WaitForChild("init"))


-- Misc
local StudioService = game:GetService("StudioService")
local ImporterStateEvent = script.Parent.Parent:WaitForChild("Events"):WaitForChild("ImporterStateEvent")




local function updateState(state)
	ImporterStateEvent:Fire(state)
end

local function getColor(color, modifier)
	return settings().Studio.Theme:GetColor(color, modifier or 0)
end


local function loadMap(title)
	local success, image = pcall(function()
		return StudioService:PromptImportFile({"png"})
	end)
	
	if success and image then
		return image
	end
end


local function loadMaps(state)
	if state.Heightmap then
		local t = tick()
		print("Loading maps, may take some time")
		wait()
		local heightmap = PNG(state.Heightmap:GetBinaryContents())
		local texturemap
		if state.Texturemap then
			texturemap = PNG(state.Texturemap:GetBinaryContents())
		end
		local h = {}
		for x, row in pairs(heightmap.pixels) do
			h[x] = {}
			for y, val in pairs(row) do
				local color = {0, 0, 0};
				if texturemap then
					color = {texturemap.pixels[x][y]["R"], texturemap.pixels[x][y]["G"], texturemap.pixels[x][y]["B"]}
				end
				h[x][y] = {val["R"], color}
			end
		end
		_G.Heightmap = h
		print("Loaded maps, took " .. math.floor((tick() - t) * 1000) / 1000 .. " seconds")
	else
		warn("You must load a heightmap")
	end
end


local function loadedColor(val)
	if val then
		return getColor(Enum.StudioStyleGuideColor.MainButton)
	else
		return getColor(Enum.StudioStyleGuideColor.Button)
	end
end


local function getHeightmap(state)
	local color = loadedColor(state.HeightmapLoaded)
	
	return Roact.createElement("Frame", {
		AnchorPoint = Vector2.new(0, 0.5);
		BackgroundColor3 = color;
		BorderSizePixel = 0;
		Position = UDim2.new(0, 0, 0.5, 0);
		Size = UDim2.new(1, 0, 1, 0);
		SizeConstraint = Enum.SizeConstraint.RelativeYY;
		ZIndex = 2;
		ClipsDescendants = true;
	}, {
		Image = Roact.createElement("ImageButton", {
			AnchorPoint = Vector2.new(0.5, 0.5);
			BackgroundTransparency = 1;
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 0.5, 0);
			Size = UDim2.new(1, -20, 1, -20);
			ZIndex = 4;
			
			Image = state.HeightmapImageId;
			
			[Roact.Event.MouseButton1Click] = function()
				local image = loadMap("Select a Heightmap")
				if image then
					state.Heightmap = image
					state.HeightmapImageId = image:GetTemporaryId()
					state.HeightmapLoaded = true
					updateState(state)
				end
			end
		});
		LoadLabel = Roact.createElement("TextLabel", {
			AnchorPoint = Vector2.new(0.5, 0.5);
			BackgroundTransparency = 1;
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 0.5, 0);
			Size = UDim2.new(1, -20, 1, -20);
			ZIndex = 3;
			Font = Enum.Font.GothamBlack;
			Text = "Load Heightmap";
			TextColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
			TextScaled = true;
			TextSize = 30;
			TextWrapped = true;
		}, {
			Roact.createElement("UITextSizeConstraint", {
				MaxTextSize = 30;
				MinTextSize = 1;
			});
		});
	});
end

local function getTexturemap(state)
	local color = loadedColor(state.TexturemapLoaded)
	
	return Roact.createElement("Frame", {
		AnchorPoint = Vector2.new(1, 0.5);
		BackgroundColor3 = color;
		BorderSizePixel = 0;
		Position = UDim2.new(1, 0, 0.5, 0);
		Size = UDim2.new(1, 0, 1, 0);
		SizeConstraint = Enum.SizeConstraint.RelativeYY;
		ZIndex = 2;
		ClipsDescendants = true;
	}, {
		Image = Roact.createElement("ImageButton", {
			AnchorPoint = Vector2.new(0.5, 0.5);
			BackgroundTransparency = 1;
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 0.5, 0);
			Size = UDim2.new(1, -20, 1, -20);
			ZIndex = 4;
			
			Image = state.TexturemapImageId;
			
			[Roact.Event.MouseButton1Click] = function()
				local image = loadMap("Select a Texturemap")
				if image then
					state.Texturemap = image
					state.TexturemapImageId = image:GetTemporaryId()
					state.TexturemapLoaded = true
					updateState(state)
				end
			end
		});
		LoadLabel = Roact.createElement("TextLabel", {
			AnchorPoint = Vector2.new(0.5, 0.5);
			BackgroundTransparency = 1;
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 0.5, 0);
			Size = UDim2.new(1, -20, 1, -20);
			ZIndex = 3;
			Font = Enum.Font.GothamBlack;
			Text = "Load Texturemap";
			TextColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
			TextScaled = true;
			TextSize = 30;
			TextWrapped = true;
		}, {
			Roact.createElement("UITextSizeConstraint", {
				MaxTextSize = 30;
				MinTextSize = 1;
			});
		});
	});
end


return function(state)
	
	local init = state
	
	return Roact.createElement("Frame", {
		Name = "Base";
		Size = UDim2.new(1, 0, 1, 0);
		BackgroundColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
		ZIndex = 1;
	}, {
		Images = Roact.createElement("Frame", {
			AnchorPoint = Vector2.new(0.5, 0);
			BackgroundTransparency = 1;
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 0, 24);
			Size = UDim2.new(1, -48, 1, -96);
			ZIndex = 1;
			ClipsDescendants = true;
		}, {
			UIAspectRatio = Roact.createElement("UIAspectRatioConstraint", {
				AspectRatio = 2.216;
			});
			Heightmap = getHeightmap(init);
			Texturemap = getTexturemap(init);
		});
		LoadButton = Roact.createElement("TextButton", {
			AnchorPoint = Vector2.new(0.5, 1);
			BackgroundColor3 = getColor(Enum.StudioStyleGuideColor.MainButton);
			BorderSizePixel = 0;
			Position = UDim2.new(0.5, 0, 1, -24);
			Size = UDim2.new(0, 260, 0, 24);
			ZIndex = 2;
			Font = Enum.Font.GothamBlack;
			Text = "Load Maps";
			TextColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
			TextScaled = true;
			TextSize = 20;
			TextWrapped = true;
			
			[Roact.Event.MouseButton1Click] = function()
				loadMaps(init)
			end
		}, {
			Roact.createElement("UITextSizeConstraint", {
				MaxTextSize = 20;
				MinTextSize = 1;
			})
		})
	})
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX107B2FE183E44E7B83C4C28608026D82">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Materials</string>
					<string name="ScriptGuid">{49CE1007-8CD9-4CB9-919B-C38E71D751DD}</string>
					<ProtectedString name="Source"><![CDATA[local Terrain = game.Workspace:WaitForChild("Terrain")

return{
	["Asphalt"] = {
		text = "Asphalt";
		enum = Enum.Material.Asphalt;
		colour = Terrain:GetMaterialColor(Enum.Material.Asphalt);
		enhanced = Color3.fromRGB(104, 108, 103);
		defaultValue = true;
	};
	["Basalt"] = {
		text = "Basalt";
		enum = Enum.Material.Basalt;
		colour = Terrain:GetMaterialColor(Enum.Material.Basalt);
		enhanced = Color3.fromRGB(66, 59, 65);
		defaultValue = true;
	};
	["Brick"] = {
		text = "Brick";
		enum = Enum.Material.Brick;
		colour = Terrain:GetMaterialColor(Enum.Material.Brick);
		enhanced = Color3.fromRGB(144, 100, 81);
		defaultValue = true;
	};
	["Cobblestone"] = {
		text = "Cobblestone";
		enum = Enum.Material.Cobblestone;
		colour = Terrain:GetMaterialColor(Enum.Material.Cobblestone);
		enhanced = Color3.fromRGB(123, 117, 87);
		defaultValue = true;
	};
	["Concrete"] = {
		text = "Concrete";
		enum = Enum.Material.Concrete;
		colour = Terrain:GetMaterialColor(Enum.Material.Concrete);
		enhanced = Color3.fromRGB(165, 159, 147);
		defaultValue = true;
	};
	["CrackedLava"] = {
		text = "CrackedLava";
		enum = Enum.Material.CrackedLava;
		colour = Terrain:GetMaterialColor(Enum.Material.CrackedLava);
		enhanced = Color3.fromRGB(60, 30, 22);
		defaultValue = true;
	};
	["Glacier"] = {
		text = "Glacier";
		enum = Enum.Material.Glacier;
		colour = Terrain:GetMaterialColor(Enum.Material.Glacier);
		enhanced = Color3.fromRGB(89, 167, 227);
		defaultValue = true;
	};
	["Grass"] = {
		text = "Grass";
		enum = Enum.Material.Grass;
		colour = Terrain:GetMaterialColor(Enum.Material.Grass);
		enhanced = Color3.fromRGB(88, 86, 35);
		defaultValue = true;
	};
	["Ground"] = {
		text = "Ground";
		enum = Enum.Material.Ground;
		colour = Terrain:GetMaterialColor(Enum.Material.Ground);
		enhanced = Color3.fromRGB(131, 122, 80);
		defaultValue = true;
	};
	["Ice"] = {
		text = "Ice";
		enum = Enum.Material.Ice;
		colour = Terrain:GetMaterialColor(Enum.Material.Ice);
		enhanced = Color3.fromRGB(119, 208, 234);
		defaultValue = true;
	};
	["LeafyGrass"] = {
		text = "LeafyGrass";
		enum = Enum.Material.LeafyGrass;
		colour = Terrain:GetMaterialColor(Enum.Material.LeafyGrass);
		enhanced = Color3.fromRGB(84, 86, 40);
		defaultValue = true;
	};
	["Limestone"] = {
		text = "Limestone";
		enum = Enum.Material.Limestone;
		colour = Terrain:GetMaterialColor(Enum.Material.Limestone);
		enhanced = Color3.fromRGB(211, 185, 143);
		defaultValue = true;
	};
	["Mud"] = {
		text = "Mud";
		enum = Enum.Material.Mud;
		colour = Terrain:GetMaterialColor(Enum.Material.Mud);
		enhanced = Color3.fromRGB(88, 74, 59);
		defaultValue = true;
	};
	["Pavement"] = {
		text = "Pavement";
		enum = Enum.Material.Pavement;
		colour = Terrain:GetMaterialColor(Enum.Material.Pavement);
		enhanced = Color3.fromRGB(103, 105, 101);
		defaultValue = true;
	};
	["Rock"] = {
		text = "Rock";
		enum = Enum.Material.Rock;
		colour = Terrain:GetMaterialColor(Enum.Material.Rock);
		enhanced = Color3.fromRGB(135, 138, 145);
		defaultValue = true;
	};
	["Salt"] = {
		text = "Salt";
		enum = Enum.Material.Salt;
		colour = Terrain:GetMaterialColor(Enum.Material.Salt);
		enhanced = Color3.fromRGB(190, 195, 198);
		defaultValue = true;
	};
	["Sand"] = {
		text = "Sand";
		enum = Enum.Material.Sand;
		colour = Terrain:GetMaterialColor(Enum.Material.Sand);
		enhanced = Color3.fromRGB(200, 172, 119);
		defaultValue = true;
	};
	["Sandstone"] = {
		text = "Sandstone";
		enum = Enum.Material.Sandstone;
		colour = Terrain:GetMaterialColor(Enum.Material.Sandstone);
		enhanced = Color3.fromRGB(123, 86, 67);
		defaultValue = true;
	};
	["Slate"] = {
		text = "Slate";
		enum = Enum.Material.Slate;
		colour = Terrain:GetMaterialColor(Enum.Material.Slate);
		enhanced = Color3.fromRGB(126, 123, 113);
		defaultValue = true;
	};
	["Snow"] = {
		text = "Snow";
		enum = Enum.Material.Snow;
		colour = Terrain:GetMaterialColor(Enum.Material.Snow);
		enhanced = Color3.fromRGB(196, 211, 224);
		defaultValue = true;
	};
	["Water"] = {
		text = "Water";
		enum = Enum.Material.Water;
		colour = Terrain.WaterColor;
		enhanced = Color3.fromRGB(98, 194, 211);
		defaultValue = false;
	};
	["WoodPlanks"] = {
		text = "WoodPlanks";
		enum = Enum.Material.WoodPlanks;
		colour = Terrain:GetMaterialColor(Enum.Material.WoodPlanks);
		enhanced = Color3.fromRGB(186, 145, 91);
		defaultValue = true;
	};
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB990987B31D5498DBFEFC95B15006BA6">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Heightmap</string>
					<string name="ScriptGuid">{38E76AF2-B4E5-4C54-BC32-7AE44F178797}</string>
					<ProtectedString name="Source"><![CDATA[-- Modules
local modules = script.Parent
local SETTINGS = require(modules:WaitForChild("SETTINGS"))
local Materials = require(modules:WaitForChild("Materials"))
local GetMaterial = require(modules:WaitForChild("GetMaterial"))


-- Events
local events = script.Parent.Parent:WaitForChild("Events")
local CancelEvent = events:WaitForChild("CancelEvent").Event


-- Variables
local VX = SETTINGS.VOXEL_SCALE


-- Functions
local function create3dTable(size)
	local ret = {};
	for x = 1, size.X do
		ret[x] = {};
		for y = 1, size.Y do
			ret[x][y] = {};
		end
	end	
	return ret;
end

local function Round(n, r)
	if not r then r = 1 end
	return math.floor((n / r) + 0.5) * r
end


return function(state)
	local Heightmap
	if not _G.Heightmap then
		warn("Please load a heightmap.")
		return
	elseif _G.Heightmap then
		Heightmap = _G.Heightmap
	end
	
	local t = tick()
	
	local ORIGIN = state.Terrain.TerrainOrigin
	
	local TERRAIN_ORIGIN = Vector3.new(
		ORIGIN.X + (-(#Heightmap * VX) / 2),
		ORIGIN.Y,
		ORIGIN.Z + (-(#Heightmap[1] * VX) / 2)
	)
	
	local Running = true
	
	print("Generating Heightmap")
	
	local WATER_ORIGIN = Vector3.new(
		(-((#Heightmap * state.Water.WaterSize) * VX) / 2),
		ORIGIN.Y,
		(-((#Heightmap[1] * state.Water.WaterSize) * VX) / 2)
	)
	
	local ExcessHeight = 0
	if state.Terrain.RemoveExcessTerrain then
		local heights = {}
		for x, row in pairs(Heightmap) do
			for y, pos in pairs(row) do
				heights[#heights + 1] = pos[1]
			end
		end
		table.sort(heights)
		ExcessHeight = math.clamp(heights[1] - SETTINGS.TERRAIN_EXCESS_HEIGHT, 1, 255)
	end
	
	if state.Water.EnableWater then
		print("Generating Water")
		
		local wH = state.Water.WaterHeight - ExcessHeight
		local waterHeight = (math.clamp(wH, 1, 255) / 255) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
		waterHeight = (waterHeight * state.Terrain.TerrainScale)
		
		local waterMaterial = Enum.Material.Water
		
		local seabedDepth = (state.Water.SeabedDepth / 255) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
		seabedDepth = seabedDepth * state.Terrain.TerrainScale
		
		local seabedMaterial = Enum.Material.Sand
					
		if state.AllowedMaterials[state.Water.SubWaterMaterial] then
			seabedMaterial = Materials[state.Water.SubWaterMaterial].enum
		end
		
		for x = 1, #Heightmap * state.Water.WaterSize do
			for z = 1, #Heightmap[1] * state.Water.WaterSize do
				
				if state.Water.GenerateSeabed then
					local seabedRegion
					
					if state.Terrain.InvertTerrain then
						seabedRegion = Region3.new(
							Vector3.new(
								WATER_ORIGIN.X + (x * VX),
								WATER_ORIGIN.Y,
								WATER_ORIGIN.Z + (z * VX)
							),
							Vector3.new(
								WATER_ORIGIN.X + ((x * VX) + VX),
								WATER_ORIGIN.Y + (seabedDepth * VX),
								WATER_ORIGIN.Z + ((z * VX) + VX)
							)
						):ExpandToGrid(VX)
					else
						seabedRegion = Region3.new(
							Vector3.new(
								WATER_ORIGIN.X + (x * VX),
								WATER_ORIGIN.Y - (seabedDepth * VX),
								WATER_ORIGIN.Z + (z * VX)
							),
							Vector3.new(
								WATER_ORIGIN.X + ((x * VX) + VX),
								WATER_ORIGIN.Y,
								WATER_ORIGIN.Z + ((z * VX) + VX)
							)
						):ExpandToGrid(VX)
					end
					
					if seabedRegion.Size.X > 0 and seabedRegion.Size.Y > 0 and seabedRegion.Size.Z > 0 then
						game.Workspace.Terrain:FillRegion(seabedRegion, VX, seabedMaterial)
					end
				end
				
				local region
				
				if state.Terrain.InvertTerrain then
					region = Region3.new(
						Vector3.new(
							WATER_ORIGIN.X + (x * VX),
							WATER_ORIGIN.Y - (waterHeight * VX),
							WATER_ORIGIN.Z + (z * VX)
						),
						Vector3.new(
							WATER_ORIGIN.X + ((x * VX) + VX),
							WATER_ORIGIN.Y,
							WATER_ORIGIN.Z + ((z * VX) + VX)
						)
					):ExpandToGrid(VX)
				else
					region = Region3.new(
						Vector3.new(
							WATER_ORIGIN.X + (x * VX),
							WATER_ORIGIN.Y,
							WATER_ORIGIN.Z + (z * VX)
						),
						Vector3.new(
							WATER_ORIGIN.X + ((x * VX) + VX),
							WATER_ORIGIN.Y + (waterHeight * VX),
							WATER_ORIGIN.Z + ((z * VX) + VX)
						)
					):ExpandToGrid(VX)
				end
				
				
				local materials = create3dTable(region.Size / VX)
				local occupancy = create3dTable(region.Size / VX)
				
				
				local occ
				if state.Terrain.OptimizeTerrain then
					occ = Round(state.Water.WaterOccupancy, SETTINGS.TERRAIN_OCCUPANCY_ROUND) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
				else
					occ = state.Water.WaterOccupancy
				end
				
				for regX = 1, region.Size.X / VX do
					for regY = 1, region.Size.Y / VX do
						for regZ = 1, region.Size.X / VX do
							materials[regX][regY][regZ] = waterMaterial
							occupancy[regX][regY][regZ] = occ
						end
					end
				end
				
				--game.Workspace.Terrain:FillRegion(region, VX, waterMaterial)
				if region.Size.X > 0 and region.Size.Y > 0 and region.Size.Z > 0 then
					game.Workspace.Terrain:WriteVoxels(region, VX, materials, occupancy)
				end
			end
			if (x % SETTINGS.WATER_GENERATION_FACTOR) == 0 then
				game:GetService("RunService").Heartbeat:Wait()
			end
		end
	end
	
	print("Generating Terrain")
	
	-- Surface Terrain
	for x, row in pairs(Heightmap) do
		for z, pos in pairs(row) do
			
			local rawHeight = ((pos[1] - ExcessHeight) / 255) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
			local height = (rawHeight * state.Terrain.TerrainScale)
			
			local region
			
			if state.Terrain.InvertTerrain then
				region = Region3.new(
					Vector3.new(
						TERRAIN_ORIGIN.X + (x * VX),
						TERRAIN_ORIGIN.Y - (height * VX),
						TERRAIN_ORIGIN.Z + (z * VX)
					),
					Vector3.new(
						TERRAIN_ORIGIN.X + ((x * VX) + VX),
						TERRAIN_ORIGIN.Y,
						TERRAIN_ORIGIN.Z + ((z * VX) + VX)
					)
				):ExpandToGrid(VX)
			else
				region = Region3.new(
					Vector3.new(
						TERRAIN_ORIGIN.X + (x * VX),
						TERRAIN_ORIGIN.Y,
						TERRAIN_ORIGIN.Z + (z * VX)
					),
					Vector3.new(
						TERRAIN_ORIGIN.X + ((x * VX) + VX),
						TERRAIN_ORIGIN.Y + (height * VX),
						TERRAIN_ORIGIN.Z + ((z * VX) + VX)
					)
				):ExpandToGrid(VX)
			end
			
			local surfaceMaterial = GetMaterial(pos, state)
			
			local materials = create3dTable(region.Size / VX)
			local occupancy = create3dTable(region.Size / VX)
			
			if state.Terrain.InvertTerrain then
				for regX = region.Size.X / VX, 1, -1 do
					for regY = region.Size.Y / VX, 1, -1 do
						local mat, occ = surfaceMaterial, 1
						
						-- Materials
						if pos[1] < state.Water.WaterHeight and state.Water.UseSubWaterMaterial then
							if state.AllowedMaterials[state.Water.SubWaterMaterial] then
								mat = Materials[state.Water.SubWaterMaterial].enum
							end
						end
						
						if state.Beach.EnableBeach then
							local beachHeight = state.Water.WaterHeight + state.Beach.BeachHeight
							local beachDepth = state.Water.WaterHeight - state.Beach.BeachDepth
							if pos[1] <= beachHeight and pos[1] >= beachDepth then
								if state.AllowedMaterials[state.Beach.BeachMaterial] then
									mat = Materials[state.Beach.BeachMaterial].enum
								end
							end
						end
						
						if state.Subsurface.UseSubsurfaceMaterial then
							if regY > (region.Size.Y / VX) * (1 - state.Subsurface.SubsurfaceHeight) then
								mat = Materials[state.Subsurface.SubsurfaceMaterial].enum
							end
						end
						
						if state.Terrain.RemoveLevelZero and pos[1] == 0 then
							mat = Enum.Material.Air
						end
						
						-- Occupancies
						if regY <= 1 + state.Terrain.SmoothDepth then
							occ = height % 1
						end
						
						if state.Terrain.RemoveLevelZero and pos[1] == 0 then
							occ = 0
						end
						
						if state.Terrain.OptimizeTerrain then
							occ = Round(occ, SETTINGS.TERRAIN_OCCUPANCY_ROUND) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
						end
						
						for regZ = region.Size.Z / VX, 1, -1 do
							materials[regX][regY][regZ] = mat
							occupancy[regX][regY][regZ] = occ
						end
					end
				end
			else
				for regX = 1, region.Size.X / VX do
					for regY = 1, region.Size.Y / VX do
						local mat, occ = surfaceMaterial, 1
						
						-- Materials
						if pos[1] < state.Water.WaterHeight and state.Water.UseSubWaterMaterial then
							if state.AllowedMaterials[state.Water.SubWaterMaterial] then
								mat = Materials[state.Water.SubWaterMaterial].enum
							end
						end
						
						if state.Beach.EnableBeach then
							local beachHeight = state.Water.WaterHeight + state.Beach.BeachHeight
							local beachDepth = state.Water.WaterHeight - state.Beach.BeachDepth
							if pos[1] <= beachHeight and pos[1] >= beachDepth then
								if state.AllowedMaterials[state.Beach.BeachMaterial] then
									mat = Materials[state.Beach.BeachMaterial].enum
								end
							end
						end
						
						if state.Subsurface.UseSubsurfaceMaterial then
							if regY < (region.Size.Y / VX) * state.Subsurface.SubsurfaceHeight then
								mat = Materials[state.Subsurface.SubsurfaceMaterial].enum
							end
						end
						
						if state.Terrain.RemoveLevelZero and pos[1] == 0 then
							mat = Enum.Material.Air
						end
						
						-- Occupancies
						if regY >= (region.Size.Y / VX) - state.Terrain.SmoothDepth then
							occ = height % 1
						end
						
						if state.Terrain.RemoveLevelZero and pos[1] == 0 then
							occ = 0
						end
						
						if state.Terrain.OptimizeTerrain then
							occ = Round(occ, SETTINGS.TERRAIN_OCCUPANCY_ROUND) + SETTINGS.TERRAIN_TINY_NUMBER_FIXER
						end
						
						for regZ = 1, region.Size.Z / VX do
							materials[regX][regY][regZ] = mat
							occupancy[regX][regY][regZ] = occ
						end
					end
				end
			end
			
			if region.Size.X > 0 and region.Size.Y > 0 and region.Size.Z > 0 then
				game.Workspace.Terrain:WriteVoxels(region, VX, materials, occupancy)
			end
		end
		if (x % SETTINGS.TERRAIN_GENERATION_FACTOR) == 0 then
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
	
	CancelEvent:Connect(function()
		Running = false
	end)
	
	print("Generation completed, time taken:", math.floor((tick() - t) * 10000) / 10000)
	
	game:GetService("ChangeHistoryService"):SetWaypoint("Terrain Generation")
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX54A586197E6347E982C3D7B9FFD80675">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Visualizer</string>
					<string name="ScriptGuid">{62A22673-511B-4A4D-8AEB-FF94466910FE}</string>
					<ProtectedString name="Source"><![CDATA[-- Modules
local SETTINGS = require(script.Parent:WaitForChild("SETTINGS"))
local GetMaterial = require(script.Parent:WaitForChild("GetMaterial"))
local Materials = require(script.Parent:WaitForChild("Materials"))
local Surface = require(script:WaitForChild("Surface"))
local Subsurface = require(script:WaitForChild("Subsurface"))
local Water = require(script:WaitForChild("Water"))
local Seabed = require(script:WaitForChild("Seabed"))
local Base = require(script:WaitForChild("Base"))

local Visualizer = {}

local VISUAL_FACTOR = SETTINGS.VISUALIZER_FACTOR


local db = false

function Visualizer:Create(state)
	if db then return end
	local Heightmap
	if not _G.Heightmap then
		warn("Please load a heightmap.")
		return
	elseif _G.Heightmap then
		Heightmap = _G.Heightmap
	end
	
	db = true
	
	if game:GetService("CoreGui"):FindFirstChild("Visualizer") then
		Visualizer:Clear()
	end
	
	Visualizer.Active = true
	
	local VisFolder = Instance.new("Folder")
	VisFolder.Archivable = false
	VisFolder.Name = "Visualizer"
	VisFolder.Parent = game:GetService("CoreGui")
	
	local SurfaceFolder = Instance.new("Folder")
	SurfaceFolder.Archivable = false
	SurfaceFolder.Name = "SurfaceFolder"
	SurfaceFolder.Parent = VisFolder
	
	local SubsurfaceFolder = Instance.new("Folder")
	SubsurfaceFolder.Archivable = false
	SubsurfaceFolder.Name = "SubsurfaceFolder"
	SubsurfaceFolder.Parent = VisFolder
	
	local VX = SETTINGS.VOXEL_SCALE
	
	local ORIGIN = state.Terrain.TerrainOrigin
	
	local TERRAIN_ORIGIN = Vector3.new(
		state.Terrain.TerrainOrigin.X + (-(#Heightmap * VX) / 2),
		state.Terrain.TerrainOrigin.Y,
		state.Terrain.TerrainOrigin.Z + (-(#Heightmap[1] * VX) / 2)
	)
	
	local ExcessHeight = 0
	if state.Terrain.RemoveExcessTerrain then
		local heights = {}
		for x, row in pairs(Heightmap) do
			for y, pos in pairs(row) do
				heights[#heights + 1] = pos[1]
			end
		end
		table.sort(heights)
		ExcessHeight = math.clamp(heights[1] - SETTINGS.TERRAIN_EXCESS_HEIGHT, 1, 255)
	end
	
	for x, row in pairs(Heightmap) do
		for z, pos in pairs(row) do
			
			local rawHeight = (pos[1] - ExcessHeight) / 255
			
			if x % VISUAL_FACTOR == 0 and z % VISUAL_FACTOR == 0 then
				
				do -- Surface terrain
					local surface = Surface(pos)
					if state.Terrain.InvertTerrain then
						surface.CFrame = CFrame.new(
							TERRAIN_ORIGIN.X + (x * VX),
							TERRAIN_ORIGIN.Y - ((rawHeight * state.Terrain.TerrainScale) * VX),
							TERRAIN_ORIGIN.Z + (z * VX)
						)
					else
						surface.CFrame = CFrame.new(
							TERRAIN_ORIGIN.X + (x * VX),
							TERRAIN_ORIGIN.Y + ((rawHeight * state.Terrain.TerrainScale) * VX),
							TERRAIN_ORIGIN.Z + (z * VX)
						)
					end
					local surfaceMat = Materials[GetMaterial(pos, state).Name].colour
					surface.Color3 = surfaceMat
					surface.Adornee = workspace.Terrain
					surface.Parent = SurfaceFolder
				end
				
				do -- Subsurface terrain
					local matCol = Materials[state.Subsurface.SubsurfaceMaterial].colour
					local subsurface = Subsurface(matCol)
					local subsurfaceHeight = state.Terrain.TerrainOrigin.Y + (rawHeight * state.Terrain.TerrainScale) * state.Subsurface.SubsurfaceHeight
					if state.Terrain.InvertTerrain then
						subsurface.CFrame = CFrame.new(
							TERRAIN_ORIGIN.X + (x * VX),
							TERRAIN_ORIGIN.Y - (subsurfaceHeight * VX),
							TERRAIN_ORIGIN.Z + (z * VX)
						)
					else
						subsurface.CFrame = CFrame.new(
							TERRAIN_ORIGIN.X + (x * VX),
							TERRAIN_ORIGIN.Y + (subsurfaceHeight * VX),
							TERRAIN_ORIGIN.Z + (z * VX)
						)
					end
					subsurface.Adornee = workspace.Terrain
					subsurface.Parent = SubsurfaceFolder
				end
				
			end
		end
		if (x % SETTINGS.VISUALIZER_CREATE_FACTOR) == 0 then
			game:GetService("RunService").Heartbeat:Wait()
		end
	end
	
	do -- Water / Seabed visualization
		if state.Water.EnableWater then
			do
				local waterVis = Water()
				local wH = state.Water.WaterHeight - ExcessHeight
				local waterHeight = math.clamp(wH, 1, 255) / 255
				if state.Terrain.InvertTerrain then
					waterVis.CFrame = CFrame.new(
						ORIGIN.X,
						ORIGIN.Y - ((waterHeight * state.Terrain.TerrainScale) * VX),
						ORIGIN.Z
					)
				else
					waterVis.CFrame = CFrame.new(
						ORIGIN.X,
						ORIGIN.Y + ((waterHeight * state.Terrain.TerrainScale) * VX),
						ORIGIN.Z
					)
				end
				waterVis.Size = Vector3.new((#Heightmap * VX) * state.Water.WaterSize, 0, (#Heightmap[1] * VX) * state.Water.WaterSize)
				waterVis.Adornee = workspace.Terrain
				waterVis.Parent = VisFolder
			end
			if state.Water.GenerateSeabed then
				local seabedVis = Seabed()
				local seabedDepth = state.Water.SeabedDepth / 255
				if state.Terrain.InvertTerrain then
					seabedVis.CFrame = CFrame.new(
						ORIGIN.X,
						ORIGIN.Y + ((seabedDepth * state.Terrain.TerrainScale) * VX),
						ORIGIN.Z
					)
				else
					seabedVis.CFrame = CFrame.new(
						ORIGIN.X,
						ORIGIN.Y - ((seabedDepth * state.Terrain.TerrainScale) * VX),
						ORIGIN.Z
					)
				end
				seabedVis.Size = Vector3.new((#Heightmap * VX) * state.Water.WaterSize, 0, (#Heightmap[1] * VX) * state.Water.WaterSize)
				seabedVis.Adornee = workspace.Terrain
				seabedVis.Parent = VisFolder
			end
		end
	end
	
	do -- Terrain Base
		local baseVis = Base()
		baseVis.CFrame = CFrame.new(ORIGIN)
		baseVis.Size = Vector3.new(#Heightmap * VX, 0, #Heightmap[1] * VX)
		baseVis.Adornee = workspace.Terrain
		baseVis.Parent = VisFolder
	end
	
	game:GetService("ChangeHistoryService"):SetWaypoint("Visualization")
	
	db = false
end

function Visualizer:Clear()
	if game:GetService("CoreGui"):FindFirstChild("Visualizer") then
		local VisFolder = game:GetService("CoreGui"):FindFirstChild("Visualizer")
		local SurfaceFolder = VisFolder:FindFirstChild("SurfaceFolder")
		local SubsurfaceFolder = VisFolder:FindFirstChild("SubsurfaceFolder")
		
		local objects = {}
		
		for i,v in pairs(SurfaceFolder:GetChildren()) do
			table.insert(objects, #objects + 1, v)
		end
		
		for i,v in pairs(SubsurfaceFolder:GetChildren()) do
			table.insert(objects, #objects + 1, v)
		end
		
		for i,v in pairs(VisFolder:GetChildren()) do
			if v:IsA("Instance") and not v:IsA("Folder") then
				v:Destroy()
			end
		end
		
		for i,v in pairs(objects) do
			if v:IsA("Instance") then
				v:Destroy()
				if (i % SETTINGS.VISUALIZER_REMOVE_FACTOR) == 0 then
					game:GetService("RunService").Heartbeat:Wait()
				end
			end
		end
		
		VisFolder:Destroy()
	end
end

return Visualizer]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC178DA6847424F32B17262837D13F292">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Surface</string>
						<string name="ScriptGuid">{8B248CA2-1C1B-4B5A-9CD9-35321DDACD06}</string>
						<ProtectedString name="Source"><![CDATA[local SETTINGS = require(script.Parent.Parent:WaitForChild("SETTINGS"))

return function(height)
	local p = Instance.new("SphereHandleAdornment")
	p.Name = "VisualSurface"
	p.Radius = SETTINGS.VISUALIZER_SURFACE_SIZE
	p.Archivable = false
	p.Transparency = SETTINGS.VISUALIZER_SURFACE_TRANSPARENCY
	if SETTINGS.VISUALIZER_SURFACE_USE_HEIGHT_COLOR then
		p.Color3 = Color3.fromRGB(height[2][1], height[2][2], height[2][3])
	else
		p.Color3 = SETTINGS.VISUALIZER_SURFACE_COLOR
	end
	return p
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDCAFB10B7FB54A86BD5801002C504B4B">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Subsurface</string>
						<string name="ScriptGuid">{2180F257-73D8-4214-B429-AF48C1276DD6}</string>
						<ProtectedString name="Source"><![CDATA[local SETTINGS = require(script.Parent.Parent:WaitForChild("SETTINGS"))

return function(col)
	local p = Instance.new("BoxHandleAdornment")
	p.Name = "VisualSubsurface"
	p.Size = SETTINGS.VISUALIZER_SUBSURFACE_SIZE
	p.Archivable = false
	p.Transparency = SETTINGS.VISUALIZER_SUBSURFACE_TRANSPARENCY
	if SETTINGS.VISUALIZER_SUBSURFACE_USE_SUBSURFACE_COLOR and col then
		p.Color3 = col
	else
		p.Color3 = SETTINGS.VISUALIZER_SUBSURFACE_COLOR
	end
	return p
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7170429B5BE543D4ADDDDF4705B1F487">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Water</string>
						<string name="ScriptGuid">{FEE98F03-628A-4A5F-BB6E-CBA266A10C31}</string>
						<ProtectedString name="Source"><![CDATA[local SETTINGS = require(script.Parent.Parent:WaitForChild("SETTINGS"))

return function()
	local p = Instance.new("BoxHandleAdornment")
	p.Name = "VisualWater"
	p.Size = SETTINGS.VISUALIZER_WATER_DEFAULT_SIZE
	p.Transparency = SETTINGS.VISUALIZER_WATER_TRANSPARENCY
	p.Color3 = SETTINGS.VISUALIZER_WATER_COLOR
	p.Archivable = false
	return p
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCA28877E08204700A6AE5FE8EF2F1FCB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Base</string>
						<string name="ScriptGuid">{B94A22CD-1AD0-4FA5-8F65-AAC637002765}</string>
						<ProtectedString name="Source"><![CDATA[local SETTINGS = require(script.Parent.Parent:WaitForChild("SETTINGS"))

return function()
	local p = Instance.new("BoxHandleAdornment")
	p.Name = "VisualBase"
	p.Size = SETTINGS.VISUALIZER_BASE_DEFAULT_SIZE
	p.Transparency = SETTINGS.VISUALIZER_BASE_TRANSPARENCY
	p.Color3 = SETTINGS.VISUALIZER_BASE_COLOR
	p.Archivable = false
	return p
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX42CA4E395A7847009CB4935D33A25E56">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Seabed</string>
						<string name="ScriptGuid">{36AF3A9A-D09E-4910-A6E6-610CD1A19333}</string>
						<ProtectedString name="Source"><![CDATA[local SETTINGS = require(script.Parent.Parent:WaitForChild("SETTINGS"))

return function()
	local p = Instance.new("BoxHandleAdornment")
	p.Name = "VisualSeabed"
	p.Size = SETTINGS.VISUALIZER_SEABED_DEFAULT_SIZE
	p.Transparency = SETTINGS.VISUALIZER_SEABED_TRANSPARENCY
	p.Color3 = SETTINGS.VISUALIZER_SEABED_COLOR
	p.Archivable = false
	return p
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXF95E218E20334864A74EA78298D51E1C">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetMaterial</string>
					<string name="ScriptGuid">{792DB2F1-9D34-417E-AFBC-3E0A6BA38B3D}</string>
					<ProtectedString name="Source"><![CDATA[-- Modules
local modules = script.Parent
local SETTINGS = require(modules:WaitForChild("SETTINGS"))
local Materials = require(modules:WaitForChild("Materials"))


local function Round(n, r)
	if not r then r = 1 end
	return math.floor((n / r) + 0.5) * r
end


return function(pos, state)
	if state.Materials.MaterialMode == 1 then
		return Materials[state.Materials.DefaultMaterial].enum
	elseif state.Materials.MaterialMode >= 1 and state.Materials.MaterialMode <= 4 then
		
		local RGB = Color3.fromRGB(pos[2][1], pos[2][2], pos[2][3])
		local rgb = Vector3.new(RGB.r, RGB.g, RGB.b)
		local r, g, b = rgb.X, rgb.Y, rgb.Z
		
		if state.Materials.MaterialMode == 2 then
			
			local mats = {}
			
			for index, material in pairs(Materials) do
				if state.AllowedMaterials[index] then
					
					local matCol = material.colour
					
					local distance = math.sqrt(
						(matCol.r - r) ^ 2 +
						(matCol.g - g) ^ 2 +
						(matCol.b - b) ^ 2
					)
					table.insert(mats, #mats + 1, {index, distance})
				end
			end
			
			table.sort(mats, function(A,B)
				if A and B then
					return A[2] < B[2]
				end
			end)
			
			return Materials[mats[1][1]].enum
		
		elseif state.Materials.MaterialMode == 3 then
			
			local mats = {}
			
			for index, material in pairs(Materials) do
				if state.AllowedMaterials[index] then
					
					local matCol = material.enhanced
					
					local distance = math.sqrt(
						(matCol.r - r) ^ 2 +
						(matCol.g - g) ^ 2 +
						(matCol.b - b) ^ 2
					)
					table.insert(mats, #mats + 1, {index, distance})
				end
			end
			
			table.sort(mats, function(A,B)
				if A and B then
					return A[2] < B[2]
				end
			end)
			
			return Materials[mats[1][1]].enum
			
		elseif state.Materials.MaterialMode == 4 then
			
			local mats = {}
			
			for index, material in pairs(Materials) do
				if state.AllowedMaterials[index] then
					
					local matCol = state.CustomColors[index]
					
					local distance = math.sqrt(
						((matCol.X / 255) - r) ^ 2 +
						((matCol.Y / 255) - g) ^ 2 +
						((matCol.Z / 255) - b) ^ 2
					)
					table.insert(mats, #mats + 1, {index, distance})
				end
			end
			
			table.sort(mats, function(A,B)
				if A and B then
					return A[2] < B[2]
				end
			end)
			
			return Materials[mats[1][1]].enum
			
		end
	else
		return Materials[state.Materials.DefaultMaterial].enum
	end
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX521DC537160C4BE589F030504981321A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SETTINGS</string>
					<string name="ScriptGuid">{8AA64E1A-45FE-445B-85B8-36E63799CCD8}</string>
					<ProtectedString name="Source"><![CDATA[return {
	MAX_TERRAIN_SCALE = 250;
	
	SMOOTH_DEPTH_MAX = 49;
	SMOOTH_DEPTH_MIN = 1;
	
	EXTRA_MATERIAL_MAX = 99;
	EXTRA_MATERIAL_MIN = 0;
	
	WATER_SIZE_MAX = 9;
	SEABED_DEPTH_MAX = 99;
	
	WATER_GENERATION_FACTOR = 4;
	WATER_OCCUPANCY = 0.0001;
	
	TERRAIN_OCCUPANCY_ROUND = 1 / 64;
	
	TERRAIN_EXCESS_HEIGHT = 8;
	
	TERRAIN_GENERATION_FACTOR = 4;
	TERRAIN_TINY_NUMBER_FIXER = 0.0000001;
	
	BEACH_HEIGHT_MAX = 49;
	BEACH_DEPTH_MAX = 49;
	
	VISUALIZER_FACTOR = 5;
	VISUALIZER_CREATE_FACTOR = 16;
	VISUALIZER_REMOVE_FACTOR = 128;
	
		VISUALIZER_SURFACE_USE_HEIGHT_COLOR = true;
		VISUALIZER_SURFACE_SIZE = 1.5;
		VISUALIZER_SURFACE_COLOR = Color3.fromRGB(195, 103, 49);
		VISUALIZER_SURFACE_TRANSPARENCY = 0;
		
		VISUALIZER_SUBSURFACE_USE_SUBSURFACE_COLOR = true;
		VISUALIZER_SUBSURFACE_SIZE = Vector3.new(3, 3, 3);
		VISUALIZER_SUBSURFACE_COLOR = Color3.new(0.5, 0.5, 0.5);
		VISUALIZER_SUBSURFACE_TRANSPARENCY = 0;
		
		VISUALIZER_WATER_DEFAULT_SIZE = Vector3.new(32, 0, 32);
		VISUALIZER_WATER_COLOR = Color3.fromRGB(4, 117, 185);
		VISUALIZER_WATER_TRANSPARENCY = 0.25;
		
		VISUALIZER_SEABED_DEFAULT_SIZE = Vector3.new(32, 0, 32);
		VISUALIZER_SEABED_COLOR = Color3.fromRGB(190, 170, 130);
		VISUALIZER_SEABED_TRANSPARENCY = 0.25;
		
		VISUALIZER_BASE_DEFAULT_SIZE = Vector3.new(32, 0, 32);
		VISUALIZER_BASE_COLOR = Color3.new(0.1, 0.1, 0.1);
		VISUALIZER_BASE_TRANSPARENCY = 0.75;
		
	VOXEL_SCALE = 4;
	VOXEL_OCCUPANCY_SCALE = 50;
}]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX909623F5BE984AB487C039962C3EF92D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GeneratorApp</string>
					<string name="ScriptGuid">{7201D286-09B6-486A-AA80-F423B9D396F6}</string>
					<ProtectedString name="Source"><![CDATA[-- Modules
local root = script.Parent.Parent
local modules = script.Parent
local roact = root:WaitForChild("Roact")

local SETTINGS = require(modules:WaitForChild("SETTINGS"))

local Roact = require(roact:WaitForChild("Roact"))
local Libs = require(roact:WaitForChild("Libs"):WaitForChild("init"))
local ExtraLibs = require(roact:WaitForChild("ExtraLibs"):WaitForChild("init"))

local Materials = require(modules:WaitForChild("Materials"))
local Visualizer = require(modules:WaitForChild("Visualizer"))
local Heightmap = require(modules:WaitForChild("Heightmap"))


-- Misc
local GeneratorStateEvent = script.Parent.Parent:WaitForChild("Events"):WaitForChild("GeneratorStateEvent")
local CancelEvent = script.Parent.Parent:WaitForChild("Events"):WaitForChild("CancelEvent")
local ResetDefaultEvent = script.Parent.Parent:WaitForChild("Events"):WaitForChild("ResetToDefault")


local function updateState(state)
	GeneratorStateEvent:Fire(state)
end


local function getColor(color, modifier)
	return settings().Studio.Theme:GetColor(color, modifier or 0)
end


local function allowedMaterials(state)
	local children = {}
	
	children.UIListLayout = Roact.createElement("UIListLayout", {
		SortOrder = Enum.SortOrder.Name;
	})
	
	local num = 0
	
	for index, material in pairs(Materials) do
		num = num + 1
		
		children[index] = Roact.createElement(Libs.Property, {
			LayoutOrder = num;
			propertyName = index;
		}, {
			Roact.createElement(ExtraLibs.StatefulCheckbox, {
				LayoutOrder = 1;
				Size = UDim2.new(0, 24, 0, 24);
				value = state.AllowedMaterials[index] or false;
				setValue = function(v)
					state.AllowedMaterials[index] = v
					updateState(state)
				end
			})
		})
	end
	
	return children
end


local function customMaterialColors(state)
	local children = {}
	
	children.UIListLayout = Roact.createElement("UIListLayout", {
		SortOrder = Enum.SortOrder.Name;
	})
	
	local num = 0
	
	for index, material in pairs(Materials) do
		num = num + 1
		
		children[index] = Roact.createElement(Libs.Property, {
			LayoutOrder = num;
			propertyName = index;
		}, {
			Roact.createElement(ExtraLibs.ColorTextbox, {
				LayoutOrder = 1;
				Size = UDim2.new(1, 0, 0, 24);
				value = state.CustomColors[index];
				setValue = function(v)
					state.CustomColors[index] = v
					updateState(state)
				end
			});
		});
	end
	
	return children
end


return function(state)
	
	local init = state
	
	return Roact.createElement("Frame", {
		Size = UDim2.new(1, 0, 1, 0);
		BackgroundColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
	}, {
		UIListLayout = Roact.createElement("UIListLayout", {
			SortOrder = Enum.SortOrder.LayoutOrder;
		});
		ControlButtons = Roact.createElement("Frame", {
			LayoutOrder = 1;
			Size = UDim2.new(1, 0, 0, 72);
			BackgroundColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
			BorderSizePixel = 0;
		}, {
			Buttons = Roact.createElement(Libs.RadioButtons, {
				LayoutOrder = 1;
				AnchorPoint = Vector2.new(0.5, 0.5);
				Position = UDim2.new(0.5, 0, 0.5, 0);
				buttonSize = UDim2.new(0, 70, 0, 48);
				buttons = {
					"Generate";
					--"Cancel";
					"Clear";
					"Visualise";
				};
				onSelect = function(i, button)
					if i == 1 then
						Heightmap(init)
					--elseif i == 2 then
					--	CancelEvent:Fire()
					elseif i == 2 then
						game.Workspace.Terrain:Clear()
						game:GetService("ChangeHistoryService"):SetWaypoint("Clear Terrain")
					elseif i == 3 then
						Visualizer:Create(init)
					end
				end
			});
		});
		Properties = Roact.createElement("ScrollingFrame", {
			LayoutOrder = 2;
			Size = UDim2.new(1, 0, 1, -72);
			BackgroundColor3 = getColor(Enum.StudioStyleGuideColor.MainBackground);
			BorderSizePixel = 0;
			TopImage = "rbxassetid://2144428525";
			MidImage = "rbxassetid://2144428525";
			BottomImage = "rbxassetid://2144428525";
			CanvasSize = UDim2.new(1, 0, 0, 210);
			
			[Roact.Event.Changed] = function(rbx)
				local UIListLayout = rbx:WaitForChild("UIListLayout")
				rbx.CanvasSize = UDim2.new(1, 0, 0, UIListLayout.AbsoluteContentSize.Y + 48)
			end
		}, {
			UIListLayout = Roact.createElement("UIListLayout", {
				SortOrder = Enum.SortOrder.LayoutOrder;
				
				[Roact.Event.Changed] = function(rbx)
					local ScrollingFrame = rbx.Parent
					local val = UDim2.new(1, 0, 0, rbx.AbsoluteContentSize.Y + 48)
					if ScrollingFrame then
						if ScrollingFrame:IsA("ScrollingFrame") and ScrollingFrame.Name == "Properties" then
							if ScrollingFrame.CanvasSize ~= val then
								ScrollingFrame.CanvasSize = val
							end
						end
					end
				end
			});
			Terrain = Roact.createElement(Libs.Section, {
				LayoutOrder = 1;
				titleText = "Terrain";
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder;
				});
				TerrainOrigin = Roact.createElement(Libs.Property, {
					LayoutOrder = 1;
					propertyName = "Terrain Origin";
				}, {
					Roact.createElement(ExtraLibs.VectorTextbox, {
						LayoutOrder = 1;
						Size = UDim2.new(1, 0, 0, 24);
						value = init.Terrain.TerrainOrigin;
						setValue = function(v)
							init.Terrain.TerrainOrigin = v
							updateState(init)
						end
					})
				});
				TerrainScale = Roact.createElement(Libs.Property, {
					LayoutOrder = 2;
					propertyName = "Terrain Scale";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.MAX_TERRAIN_SCALE;
						sliderSnap = 1;
						unrestricted = true;
						value = init.Terrain.TerrainScale;
						setValue = function(v)
							init.Terrain.TerrainScale = v
							updateState(init)
						end
					});
				});
				--[[
				RemoveExcessTerrain = Roact.createElement(Libs.Property, {
					LayoutOrder = -2;
					propertyName = "Remove Excess Terrain";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Terrain.RemoveExcessTerrain;
						setValue = function(v)
							init.Terrain.RemoveExcessTerrain = v
							updateState(init)
						end
					});
				});
				--]]
				SmoothDepth = Roact.createElement(Libs.Property, {
					LayoutOrder = 4;
					propertyName = "Terrain Smooth Depth";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.SMOOTH_DEPTH_MAX;
						sliderMin = SETTINGS.SMOOTH_DEPTH_MIN;
						sliderSnap = 1;
						value = init.Terrain.SmoothDepth;
						setValue = function(v)
							init.Terrain.SmoothDepth = v
							updateState(init)
						end
					});
				});
				RemoveLevelZero = Roact.createElement(Libs.Property, {
					LayoutOrder = 5;
					propertyName = "Remove Level 0";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Terrain.RemoveLevelZero;
						setValue = function(v)
							init.Terrain.RemoveLevelZero = v
							updateState(init)
						end
					});
				});
				InvertTerrain = Roact.createElement(Libs.Property, {
					LayoutOrder = 6;
					propertyName = "Invert Terrain";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Terrain.InvertTerrain;
						setValue = function(v)
							init.Terrain.InvertTerrain = v
							updateState(init)
						end
					});
				});
				OptimizeTerrain = Roact.createElement(Libs.Property, {
					LayoutOrder = 7;
					propertyName = "Optimize Terrain";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Terrain.OptimizeTerrain;
						setValue = function(v)
							init.Terrain.OptimizeTerrain = v
							updateState(init)
						end
					})
				});
				RemoveExcessTerrain = Roact.createElement(Libs.Property, {
					LayoutOrder = 8;
					propertyName = "Remove Excess Terrain";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Terrain.RemoveExcessTerrain;
						setValue = function(v)
							init.Terrain.RemoveExcessTerrain = v
							updateState(init)
						end
					})
				});
			});
			Materials = Roact.createElement(Libs.Section, {
				LayoutOrder = 4;
				titleText = "Materials";
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder;
				});
				DefaultMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 1;
					propertyName = "Default Material";
				}, {
					Roact.createElement(ExtraLibs.MaterialTextbox, {
						LayoutOrder = 1;
						Size = UDim2.new(1, 0, 1, 0);
						value = init.Materials.DefaultMaterial;
						setValue = function(v)
							init.Materials.DefaultMaterial = v
							updateState(init)
						end
					});
				});
				MaterialMode = Roact.createElement(Libs.Property, {
					LayoutOrder = 2;
					propertyName = "Material Mode";
					propertyLabelSize = Vector2.new(180, 110);
				}, {
					Roact.createElement(ExtraLibs.StatefulRadioListButtons, {
						LayoutOrder = 1;
						selected = init.Materials.MaterialMode;
						buttons = {
							"Disabled";
							"Roblox Default";
							"Enhanced";
							"Custom";
						};
						onSelect = function(i, button)
							init.Materials.MaterialMode = i
							updateState(init)
						end
					});
				});
			});
			Subsurface = Roact.createElement(Libs.Section, {
				LayoutOrder = 5;
				titleText = "Subsurface Material Settings";
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder;
				});
				UseSubsurfaceMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 1;
					propertyName = "Use Subsurface Material";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Subsurface.UseSubsurfaceMaterial;
						setValue = function(v)
							init.Subsurface.UseSubsurfaceMaterial = v
							updateState(init)
						end
					});
				});
				SubsurfaceMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 2;
					propertyName = "Subsurface Material";
				}, {
					Roact.createElement(ExtraLibs.MaterialTextbox, {
						LayoutOrder = 1;
						Size = UDim2.new(1, 0, 1, 0);
						value = init.Subsurface.SubsurfaceMaterial;
						setValue = function(v)
							init.Subsurface.SubsurfaceMaterial = v
							updateState(init)
						end
					});
				});
				SubsurfaceHeight = Roact.createElement(Libs.Property, {
					LayoutOrder = 3;
					propertyName = "Subsurface Height";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = 1;
						sliderSnap = 0.001;
						value = init.Subsurface.SubsurfaceHeight;
						setValue = function(v)
							init.Subsurface.SubsurfaceHeight = v
							updateState(init)
						end
					});
				});
			});
			Water = Roact.createElement(Libs.Section, {
				LayoutOrder = 6;
				titleText = "Water";
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder;
				});
				EnableWater = Roact.createElement(Libs.Property, {
					LayoutOrder = 1;
					propertyName = "Enable Water";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Water.EnableWater;
						setValue = function(v)
							init.Water.EnableWater = v
							updateState(init)
						end
					});
				});
				WaterHeight = Roact.createElement(Libs.Property, {
					LayoutOrder = 2;
					propertyName = "Water Height";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = 255;
						sliderSnap = 1;
						value = init.Water.WaterHeight;
						setValue = function(v)
							init.Water.WaterHeight = v
							updateState(init)
						end
					});
				});
				
				WaterOccupancy = Roact.createElement(Libs.Property, {
					LayoutOrder = 3;
					propertyName = "Water Occupancy";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = 1;
						sliderSnap = 0.000001;
						value = init.Water.WaterOccupancy;
						setValue = function(v)
							init.Water.WaterOccupancy = v
							updateState(init)
						end
					});
				});
				
				WaterSize = Roact.createElement(Libs.Property, {
					LayoutOrder = 4;
					propertyName = "Water Size";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.WATER_SIZE_MAX;
						sliderMin = 1;
						sliderSnap = 1;
						value = init.Water.WaterSize;
						setValue = function(v)
							init.Water.WaterSize = v
							updateState(init)
						end
					});
				});
				UseSubWaterMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 5;
					propertyName = "Use Subwater Material";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Water.UseSubWaterMaterial;
						setValue = function(v)
							init.Water.UseSubWaterMaterial = v
							updateState(init)
						end
					});
				});
				SubWaterMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 6;
					propertyName = "Subwater Material";
				}, {
					Roact.createElement(ExtraLibs.MaterialTextbox, {
						LayoutOrder = 1;
						Size = UDim2.new(1, 0, 1, 0);
						value = init.Water.SubWaterMaterial;
						setValue = function(v)
							init.Water.SubWaterMaterial = v
							updateState(init)
						end
					});
				});
				GenerateSeabed = Roact.createElement(Libs.Property, {
					LayoutOrder = 7;
					propertyName = "Generate Seabed";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Water.GenerateSeabed;
						setValue = function(v)
							init.Water.GenerateSeabed = v
							updateState(init)
						end
					});
				});
				SeabedDepth = Roact.createElement(Libs.Property, {
					LayoutOrder = 8;
					propertyName = "Seabed Depth";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.SEABED_DEPTH_MAX;
						sliderMin = 1;
						sliderSnap = 1;
						value = init.Water.SeabedDepth;
						setValue = function(v)
							init.Water.SeabedDepth = v
							updateState(init)
						end
					});
				});
			});
			Beach = Roact.createElement(Libs.Section, {
				LayoutOrder = 7;
				titleText = "Beach";
			}, {
				UIListLayout = Roact.createElement("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder;
				});
				EnableBeach = Roact.createElement(Libs.Property, {
					LayoutOrder = 1;
					propertyName = "Enable Beach";
				}, {
					Roact.createElement(ExtraLibs.StatefulCheckbox, {
						LayoutOrder = 1;
						Size = UDim2.new(0, 24, 0, 24);
						value = init.Beach.EnableBeach;
						setValue = function(v)
							init.Beach.EnableBeach = v
							updateState(init)
						end
					});
				});
				BeachHeight = Roact.createElement(Libs.Property, {
					LayoutOrder = 2;
					propertyName = "Beach Height";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.BEACH_HEIGHT_MAX;
						sliderSnap = 1;
						value = init.Beach.BeachHeight;
						setValue = function(v)
							init.Beach.BeachHeight = v
							updateState(init)
						end
					});
				});
				BeachDepth = Roact.createElement(Libs.Property, {
					LayoutOrder = 3;
					propertyName = "Beach Depth";
				}, {
					Roact.createElement(ExtraLibs.LabeledSlider, {
						LayoutOrder = 1;
						Size = UDim2.new(1, -24, 0, 24);
						sliderMax = SETTINGS.BEACH_DEPTH_MAX;
						sliderSnap = 1;
						value = init.Beach.BeachDepth;
						setValue = function(v)
							init.Beach.BeachDepth = v
							updateState(init)
						end
					});
				});
				BeachMaterial = Roact.createElement(Libs.Property, {
					LayoutOrder = 4;
					propertyName = "Beach Material";
				}, {
					Roact.createElement(ExtraLibs.MaterialTextbox, {
						LayoutOrder = 1;
						Size = UDim2.new(1, 0, 1, 0);
						value = init.Beach.BeachMaterial;
						setValue = function(v)
							init.Beach.BeachMaterial = v
							updateState(init)
						end
					});
				});
			});
			AllowedMaterials = Roact.createElement(Libs.Section, {
				LayoutOrder = 8;
				titleText = "Allowed Materials";
			}, allowedMaterials(state));
			CustomMaterials = Roact.createElement(Libs.Section, {
				LayoutOrder = 9;
				titleText = "Custom Materials";
			}, customMaterialColors(state));
			--[[
			VisualizerSettings = Roact.createElement(Libs.Section, {
				LayoutOrder = 15;
				titleText = "Visualizer Settings";
			}, {
				VisualizerFactor = Roact.createElement(Libs.Property, {
					
				});
			});
			--[[
			ResetDefaultButton = Roact.createElement(Libs.Button, {
				LayoutOrder = 20;
				labelText = "Reset settings to default";
				Size = UDim2.new(1, 0, 0, 24);
				onClick = function()
					print("Reseting settings to default");
					ResetDefaultEvent:Fire()
				end
			})
			--]]
		});
	})
end]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXF0150E5EA1394CE59539836B2AD75511">
				<Properties>
					<string name="Name">PNG</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC716DEAD66C245FD83DF427782E25179">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DEFLATE</string>
						<string name="ScriptGuid">{2D475685-E38C-49CD-AE72-1429E11B66EF}</string>
						<ProtectedString name="Source"><![CDATA[--[[

LUA MODULE

compress.deflatelua - deflate (and gunzip/zlib) implemented in Lua.

SYNOPSIS
local DEFLATE = require 'compress.deflatelua'
-- uncompress gzip file
local fh = assert(io.open'foo.txt.gz', 'rb')
local ofh = assert(io.open'foo.txt', 'wb')
DEFLATE.gunzip {input=fh, output=ofh}
fh:close(); ofh:close()
-- can also uncompress from string including zlib and raw DEFLATE formats.
DESCRIPTION
This is a pure Lua implementation of decompressing the DEFLATE format,
including the related zlib and gzip formats.
Note: This library only supports decompression.
Compression is not currently implemented.

API

Note: in the following functions, input stream `fh` may be
a file handle, string, or an iterator function that returns strings.
Output stream `ofh` may be a file handle or a function that
consumes one byte (number 0..255) per call.

DEFLATE.inflate {input=fh, output=ofh}

Decompresses input stream `fh` in the DEFLATE format
while writing to output stream `ofh`.
DEFLATE is detailed in http://tools.ietf.org/html/rfc1951 .
DEFLATE.gunzip {input=fh, output=ofh, disable_crc=disable_crc}
Decompresses input stream `fh` with the gzip format
while writing to output stream `ofh`.
`disable_crc` (defaults to `false`) will disable CRC-32 checking
to increase speed.
gzip is detailed in http://tools.ietf.org/html/rfc1952 .

DEFLATE.inflate_zlib {input=fh, output=ofh, disable_crc=disable_crc}
Decompresses input stream `fh` with the zlib format
while writing to output stream `ofh`.
`disable_crc` (defaults to `false`) will disable CRC-32 checking
to increase speed.
zlib is detailed in http://tools.ietf.org/html/rfc1950 .

DEFLATE.adler32(byte, crc) --> rcrc
Returns adler32 checksum of byte `byte` (number 0..255) appended
to string with adler32 checksum `crc`. This is internally used by
`inflate_zlib`.
ADLER32 in detailed in http://tools.ietf.org/html/rfc1950 .

COMMAND LINE UTILITY

A `gunziplua` command line utility (in folder `bin`) is also provided.
This mimicks the *nix `gunzip` utility but is a pure Lua implementation
that invokes this library. For help do
gunziplua -h
DEPENDENCIES

Requires 'digest.crc32lua' (used for optional CRC-32 checksum checks).
https://github.com/davidm/lua-digest-crc32lua

Will use a bit library ('bit', 'bit32', 'bit.numberlua') if available. This
is not that critical for this library but is required by digest.crc32lua.

'pythonic.optparse' is only required by the optional `gunziplua`
command-line utilty for command line parsing.
https://github.com/davidm/lua-pythonic-optparse

INSTALLATION

Copy the `compress` directory into your LUA_PATH.
REFERENCES

[1] DEFLATE Compressed Data Format Specification version 1.3
http://tools.ietf.org/html/rfc1951
[2] GZIP file format specification version 4.3
http://tools.ietf.org/html/rfc1952
[3] http://en.wikipedia.org/wiki/DEFLATE
[4] pyflate, by Paul Sladen
http://www.paul.sladen.org/projects/pyflate/
[5] Compress::Zlib::Perl - partial pure Perl implementation of
Compress::Zlib
http://search.cpan.org/~nwclark/Compress-Zlib-Perl/Perl.pm

LICENSE

(c) 2008-2011 David Manura. Licensed under the same terms as Lua (MIT).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
(end license)
--]]

local M = {_TYPE='module', _NAME='compress.deflatelua', _VERSION='0.3.20111128'}

local assert = assert
local error = error
local ipairs = ipairs
local pairs = pairs
local print = print
local require = require
local tostring = tostring
local type = type
local setmetatable = setmetatable
local io = io
local math = math
local table_sort = table.sort
local math_max = math.max
local string_char = string.char

--[[
Requires the first module listed that exists, else raises like `require`.
If a non-string is encountered, it is returned.
Second return value is module name loaded (or '').
--]]
local function requireany(...)
  local errs = {}
  for i = 1, select('#', ...) do local name = select(i, ...)
    if type(name) ~= 'string' then return name, '' end
    local ok, mod = pcall(require, name)
    if ok then return mod, name end
    errs[#errs+1] = mod
  end
  error(table.concat(errs, '\n'), 2)
end


--local crc32 = require "digest.crc32lua" . crc32_byte
local bit, name_ = requireany('bit', 'bit32', 'bit.numberlua', nil)

local DEBUG = false

-- Whether to use `bit` library functions in current module.
-- Unlike the crc32 library, it doesn't make much difference in this module.
local NATIVE_BITOPS = (bit ~= nil)

local band, lshift, rshift
if NATIVE_BITOPS then
  band = bit.band
  lshift = bit.lshift
  rshift = bit.rshift
end


local function warn(s)
  io.stderr:write(s, '\n')
end


local function debug(...)
  print('DEBUG', ...)
end


local function runtime_error(s, level)
  level = level or 1
  error({s}, level+1)
end


local function make_outstate(outbs)
  local outstate = {}
  outstate.outbs = outbs
  outstate.window = {}
  outstate.window_pos = 1
  return outstate
end


local function output(outstate, byte)
  -- debug('OUTPUT:', s)
  local window_pos = outstate.window_pos
  outstate.outbs(byte)
  outstate.window[window_pos] = byte
  outstate.window_pos = window_pos % 32768 + 1 -- 32K
end


local function noeof(val)
  return assert(val, 'unexpected end of file')
end


local function hasbit(bits, bit)
  return bits % (bit + bit) >= bit
end


local function memoize(f)
  local mt = {}
  local t = setmetatable({}, mt)
  function mt:__index(k)
    local v = f(k)
    t[k] = v
    return v
  end
  return t
end


-- small optimization (lookup table for powers of 2)
local pow2 = memoize(function(n) return 2^n end)

--local tbits = memoize(
-- function(bits)
-- return memoize( function(bit) return getbit(bits, bit) end )
-- end )


-- weak metatable marking objects as bitstream type
local is_bitstream = setmetatable({}, {__mode='k'})


-- DEBUG
-- prints LSB first
--[[
local function bits_tostring(bits, nbits)
local s = ''
local tmp = bits
local function f()
local b = tmp % 2 == 1 and 1 or 0
s = s .. b
tmp = (tmp - b) / 2
end
if nbits then
for i=1,nbits do f() end
else
while tmp ~= 0 do f() end
end

return s
end
--]]

local function bytestream_from_file(fh)
  local o = {}
  function o:read()
    local sb = fh:read(1)
    if sb then return sb:byte() end
  end
  return o
end


local function bytestream_from_string(s)
  local i = 1
  local o = {}
  function o:read()
    local by
    if i <= #s then
      by = s:byte(i)
      i = i + 1
    end
    return by
  end
  return o
end


local function bytestream_from_function(f)
  local i = 0
  local buffer = ''
  local o = {}
  function o:read()
    i = i + 1
    if i > #buffer then
      buffer = f()
      if not buffer then return end
      i = 1
    end
    return buffer:byte(i,i)
  end
  return o
end


local function bitstream_from_bytestream(bys)
  local buf_byte = 0
  local buf_nbit = 0
  local o = {}

  function o:nbits_left_in_byte()
    return buf_nbit
  end

  if NATIVE_BITOPS then
    function o:read(nbits)
      nbits = nbits or 1
      while buf_nbit < nbits do
        local byte = bys:read()
        if not byte then return end -- note: more calls also return nil
        buf_byte = buf_byte + lshift(byte, buf_nbit)
        buf_nbit = buf_nbit + 8
      end
      local bits
      if nbits == 0 then
        bits = 0
      elseif nbits == 32 then
        bits = buf_byte
        buf_byte = 0
      else
        bits = band(buf_byte, rshift(0xffffffff, 32 - nbits))
        buf_byte = rshift(buf_byte, nbits)
      end
      buf_nbit = buf_nbit - nbits
      return bits
    end
  else
    function o:read(nbits)
      nbits = nbits or 1
      while buf_nbit < nbits do
        local byte = bys:read()
        if not byte then return end -- note: more calls also return nil
        buf_byte = buf_byte + pow2[buf_nbit] * byte
        buf_nbit = buf_nbit + 8
      end
      local m = pow2[nbits]
      local bits = buf_byte % m
      buf_byte = (buf_byte - bits) / m
      buf_nbit = buf_nbit - nbits
      return bits
    end
  end
  
  is_bitstream[o] = true

  return o
end


local function get_bitstream(o)
  local bs
  if is_bitstream[o] then
    return o
--  elseif io.type(o) == 'file' then
--    bs = bitstream_from_bytestream(bytestream_from_file(o))
  elseif type(o) == 'string' then
    bs = bitstream_from_bytestream(bytestream_from_string(o))
  elseif type(o) == 'function' then
    bs = bitstream_from_bytestream(bytestream_from_function(o))
  else
    runtime_error 'unrecognized type'
  end
  return bs
end


local function get_obytestream(o)
  local bs
--[[  if io.type(o) == 'file' then
    bs = function(sbyte) o:write(string_char(sbyte)) end
  else--]]if type(o) == 'function' then
    bs = o
  else
    runtime_error('unrecognized type: ' .. tostring(o))
  end
  return bs
end


local function HuffmanTable(init, is_full)
  local t = {}
  if is_full then
    for val,nbits in pairs(init) do
      if nbits ~= 0 then
        t[#t+1] = {val=val, nbits=nbits}
        --debug('*',val,nbits)
      end
    end
  else
    for i=1,#init-2,2 do
      local firstval, nbits, nextval = init[i], init[i+1], init[i+2]
      --debug(val, nextval, nbits)
      if nbits ~= 0 then
        for val=firstval,nextval-1 do
          t[#t+1] = {val=val, nbits=nbits}
        end
      end
    end
  end
  table_sort(t, function(a,b)
    return a.nbits == b.nbits and a.val < b.val or a.nbits < b.nbits
  end)

  -- assign codes
  local code = 1 -- leading 1 marker
  local nbits = 0
  for i,s in ipairs(t) do
    if s.nbits ~= nbits then
      code = code * pow2[s.nbits - nbits]
      nbits = s.nbits
    end
    s.code = code
    --debug('huffman code:', i, s.nbits, s.val, code, bits_tostring(code))
    code = code + 1
  end

  local minbits = math.huge
  local look = {}
  for i,s in ipairs(t) do
    minbits = math.min(minbits, s.nbits)
    look[s.code] = s.val
  end

  --for _,o in ipairs(t) do
  -- debug(':', o.nbits, o.val)
  --end

  -- function t:lookup(bits) return look[bits] end

  local msb = NATIVE_BITOPS and function(bits, nbits)
    local res = 0
    for i=1,nbits do
      res = lshift(res, 1) + band(bits, 1)
      bits = rshift(bits, 1)
    end
    return res
  end or function(bits, nbits)
    local res = 0
    for i=1,nbits do
      local b = bits % 2
      bits = (bits - b) / 2
      res = res * 2 + b
    end
    return res
  end
  
  local tfirstcode = memoize(
    function(bits) return pow2[minbits] + msb(bits, minbits) end)

  function t:read(bs)
    local code = 1 -- leading 1 marker
    local nbits = 0
    while 1 do
      if nbits == 0 then -- small optimization (optional)
        code = tfirstcode[noeof(bs:read(minbits))]
        nbits = nbits + minbits
      else
        local b = noeof(bs:read())
        nbits = nbits + 1
        code = code * 2 + b -- MSB first
        --[[NATIVE_BITOPS
code = lshift(code, 1) + b -- MSB first
--]]
      end
      --debug('code?', code, bits_tostring(code))
      local val = look[code]
      if val then
        --debug('FOUND', val)
        return val
      end
    end
  end

  return t
end


local function parse_gzip_header(bs)
  -- local FLG_FTEXT = 2^0
  local FLG_FHCRC = 2^1
  local FLG_FEXTRA = 2^2
  local FLG_FNAME = 2^3
  local FLG_FCOMMENT = 2^4

  local id1 = bs:read(8)
  local id2 = bs:read(8)
  if id1 ~= 31 or id2 ~= 139 then
    runtime_error 'not in gzip format'
  end
  local cm = bs:read(8) -- compression method
  local flg = bs:read(8) -- FLaGs
  local mtime = bs:read(32) -- Modification TIME
  local xfl = bs:read(8) -- eXtra FLags
  local os = bs:read(8) -- Operating System

  if DEBUG then
    debug("CM=", cm)
    debug("FLG=", flg)
    debug("MTIME=", mtime)
    -- debug("MTIME_str=",os.date("%Y-%m-%d %H:%M:%S",mtime)) -- non-portable
    debug("XFL=", xfl)
    debug("OS=", os)
  end

  if not os then runtime_error 'invalid header' end

  if hasbit(flg, FLG_FEXTRA) then
    local xlen = bs:read(16)
    local extra = 0
    for i=1,xlen do
      extra = bs:read(8)
    end
    if not extra then runtime_error 'invalid header' end
  end

  local function parse_zstring(bs)
    repeat
      local by = bs:read(8)
      if not by then runtime_error 'invalid header' end
    until by == 0
  end

  if hasbit(flg, FLG_FNAME) then
    parse_zstring(bs)
  end

  if hasbit(flg, FLG_FCOMMENT) then
    parse_zstring(bs)
  end

  if hasbit(flg, FLG_FHCRC) then
    local crc16 = bs:read(16)
    if not crc16 then runtime_error 'invalid header' end
    -- IMPROVE: check CRC. where is an example .gz file that
    -- has this set?
    if DEBUG then
      debug("CRC16=", crc16)
    end
  end
end

local function parse_zlib_header(bs)
  local cm = bs:read(4) -- Compression Method
  local cinfo = bs:read(4) -- Compression info
  local fcheck = bs:read(5) -- FLaGs: FCHECK (check bits for CMF and FLG)
  local fdict = bs:read(1) -- FLaGs: FDICT (present dictionary)
  local flevel = bs:read(2) -- FLaGs: FLEVEL (compression level)
  local cmf = cinfo * 16 + cm -- CMF (Compresion Method and flags)
  local flg = fcheck + fdict * 32 + flevel * 64 -- FLaGs
  
  if cm ~= 8 then -- not "deflate"
    runtime_error("unrecognized zlib compression method: " .. cm)
  end
  if cinfo > 7 then
    runtime_error("invalid zlib window size: cinfo=" .. cinfo)
  end
  local window_size = 2^(cinfo + 8)
  
  if (cmf*256 + flg) % 31 ~= 0 then
    runtime_error("invalid zlib header (bad fcheck sum)")
  end
  
  if fdict == 1 then
    runtime_error("FIX:TODO - FDICT not currently implemented")
    local dictid_ = bs:read(32)
  end
  
  return window_size
end

local function parse_huffmantables(bs)
    local hlit = bs:read(5) -- # of literal/length codes - 257
    local hdist = bs:read(5) -- # of distance codes - 1
    local hclen = noeof(bs:read(4)) -- # of code length codes - 4

    local ncodelen_codes = hclen + 4
    local codelen_init = {}
    local codelen_vals = {
      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}
    for i=1,ncodelen_codes do
      local nbits = bs:read(3)
      local val = codelen_vals[i]
      codelen_init[val] = nbits
    end
    local codelentable = HuffmanTable(codelen_init, true)

    local function decode(ncodes)
      local init = {}
      local nbits
      local val = 0
      while val < ncodes do
        local codelen = codelentable:read(bs)
        --FIX:check nil?
        local nrepeat
        if codelen <= 15 then
          nrepeat = 1
          nbits = codelen
          --debug('w', nbits)
        elseif codelen == 16 then
          nrepeat = 3 + noeof(bs:read(2))
          -- nbits unchanged
        elseif codelen == 17 then
          nrepeat = 3 + noeof(bs:read(3))
          nbits = 0
        elseif codelen == 18 then
          nrepeat = 11 + noeof(bs:read(7))
          nbits = 0
        else
          error 'ASSERT'
        end
        for i=1,nrepeat do
          init[val] = nbits
          val = val + 1
        end
      end
      local huffmantable = HuffmanTable(init, true)
      return huffmantable
    end

    local nlit_codes = hlit + 257
    local ndist_codes = hdist + 1

    local littable = decode(nlit_codes)
    local disttable = decode(ndist_codes)

    return littable, disttable
end


local tdecode_len_base
local tdecode_len_nextrabits
local tdecode_dist_base
local tdecode_dist_nextrabits
local function parse_compressed_item(bs, outstate, littable, disttable)
  local val = littable:read(bs)
  --debug(val, val < 256 and string_char(val))
  if val < 256 then -- literal
    output(outstate, val)
  elseif val == 256 then -- end of block
    return true
  else
    if not tdecode_len_base then
      local t = {[257]=3}
      local skip = 1
      for i=258,285,4 do
        for j=i,i+3 do t[j] = t[j-1] + skip end
        if i ~= 258 then skip = skip * 2 end
      end
      t[285] = 258
      tdecode_len_base = t
      --for i=257,285 do debug('T1',i,t[i]) end
    end
    if not tdecode_len_nextrabits then
      local t = {}
      if NATIVE_BITOPS then
        for i=257,285 do
          local j = math_max(i - 261, 0)
          t[i] = rshift(j, 2)
        end
      else
        for i=257,285 do
          local j = math_max(i - 261, 0)
          t[i] = (j - (j % 4)) / 4
        end
      end
      t[285] = 0
      tdecode_len_nextrabits = t
      --for i=257,285 do debug('T2',i,t[i]) end
    end
    local len_base = tdecode_len_base[val]
    local nextrabits = tdecode_len_nextrabits[val]
    local extrabits = bs:read(nextrabits)
    local len = len_base + extrabits

    if not tdecode_dist_base then
      local t = {[0]=1}
      local skip = 1
      for i=1,29,2 do
        for j=i,i+1 do t[j] = t[j-1] + skip end
        if i ~= 1 then skip = skip * 2 end
      end
      tdecode_dist_base = t
      --for i=0,29 do debug('T3',i,t[i]) end
    end
    if not tdecode_dist_nextrabits then
      local t = {}
      if NATIVE_BITOPS then
        for i=0,29 do
          local j = math_max(i - 2, 0)
          t[i] = rshift(j, 1)
        end
      else
        for i=0,29 do
          local j = math_max(i - 2, 0)
          t[i] = (j - (j % 2)) / 2
        end
      end
      tdecode_dist_nextrabits = t
      --for i=0,29 do debug('T4',i,t[i]) end
    end
    local dist_val = disttable:read(bs)
    local dist_base = tdecode_dist_base[dist_val]
    local dist_nextrabits = tdecode_dist_nextrabits[dist_val]
    local dist_extrabits = bs:read(dist_nextrabits)
    local dist = dist_base + dist_extrabits

    --debug('BACK', len, dist)
    for i=1,len do
      local pos = (outstate.window_pos - 1 - dist) % 32768 + 1 -- 32K
      output(outstate, assert(outstate.window[pos], 'invalid distance'))
    end
  end
  return false
end


local function parse_block(bs, outstate)
  local bfinal = bs:read(1)
  local btype = bs:read(2)

  local BTYPE_NO_COMPRESSION = 0
  local BTYPE_FIXED_HUFFMAN = 1
  local BTYPE_DYNAMIC_HUFFMAN = 2
  local BTYPE_RESERVED_ = 3

  if DEBUG then
    debug('bfinal=', bfinal)
    debug('btype=', btype)
  end

  if btype == BTYPE_NO_COMPRESSION then
    bs:read(bs:nbits_left_in_byte())
    local len = bs:read(16)
    local nlen_ = noeof(bs:read(16))

    for i=1,len do
      local by = noeof(bs:read(8))
      output(outstate, by)
    end
  elseif btype == BTYPE_FIXED_HUFFMAN or btype == BTYPE_DYNAMIC_HUFFMAN then
    local littable, disttable
    if btype == BTYPE_DYNAMIC_HUFFMAN then
      littable, disttable = parse_huffmantables(bs)
    else
      littable = HuffmanTable {0,8, 144,9, 256,7, 280,8, 288,nil}
      disttable = HuffmanTable {0,5, 32,nil}
    end

    repeat
      local is_done = parse_compressed_item(
        bs, outstate, littable, disttable)
    until is_done
  else
    runtime_error 'unrecognized compression type'
  end

  return bfinal ~= 0
end


function M.inflate(t)
  local bs = get_bitstream(t.input)
  local outbs = get_obytestream(t.output)
  local outstate = make_outstate(outbs)

  repeat
    local is_final = parse_block(bs, outstate)
  until is_final
end
local inflate = M.inflate


function M.gunzip(t)
  local bs = get_bitstream(t.input)
  local outbs = get_obytestream(t.output)
  local disable_crc = t.disable_crc
  if disable_crc == nil then disable_crc = false end

  parse_gzip_header(bs)

  local data_crc32 = 0

  inflate{input=bs, output=
    disable_crc and outbs or
      function(byte)
        data_crc32 = crc32(byte, data_crc32)
        outbs(byte)
      end
  }

  bs:read(bs:nbits_left_in_byte())

  local expected_crc32 = bs:read(32)
  local isize = bs:read(32) -- ignored
  if DEBUG then
    debug('crc32=', expected_crc32)
    debug('isize=', isize)
  end
  if not disable_crc and data_crc32 then
    if data_crc32 ~= expected_crc32 then
      runtime_error('invalid compressed data--crc error')
    end
  end
  if bs:read() then
    warn 'trailing garbage ignored'
  end
end


function M.adler32(byte, crc)
  local s1 = crc % 65536
  local s2 = (crc - s1) / 65536
  s1 = (s1 + byte) % 65521
  s2 = (s2 + s1) % 65521
  return s2*65536 + s1
end -- 65521 is the largest prime smaller than 2^16


function M.inflate_zlib(t)
  local bs = get_bitstream(t.input)
  local outbs = get_obytestream(t.output)
  local disable_crc = t.disable_crc
  if disable_crc == nil then disable_crc = false end
  
  local window_size_ = parse_zlib_header(bs)
  
  local data_adler32 = 1
  
  inflate{input=bs, output=
    disable_crc and outbs or
      function(byte)
        data_adler32 = M.adler32(byte, data_adler32)
        outbs(byte)
      end
  }

  bs:read(bs:nbits_left_in_byte())
  
  local b3 = bs:read(8)
  local b2 = bs:read(8)
  local b1 = bs:read(8)
  local b0 = bs:read(8)
  local expected_adler32 = ((b3*256 + b2)*256 + b1)*256 + b0
  if DEBUG then
    debug('alder32=', expected_adler32)
  end
  if not disable_crc then
    if data_adler32 ~= expected_adler32 then
      runtime_error('invalid compressed data--crc error')
    end
  end
  if bs:read() then
    warn 'trailing garbage ignored'
  end
end


return M]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9ECE30C63ABD41398EEE620336AEFC55">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PNG</string>
						<string name="ScriptGuid">{E9C632E6-39E7-4F69-A76A-A97F57FA7CC1}</string>
						<ProtectedString name="Source"><![CDATA[-- The MIT License (MIT)

-- Copyright (c) 2013 DelusionalLogic

-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
-- the Software, and to permit persons to whom the Software is furnished to do so,
-- subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
-- FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-- COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
-- IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-- CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

local deflate = require(script.Parent.DEFLATE)
local requiredDeflateVersion = "0.3.20111128"

if (deflate._VERSION ~= requiredDeflateVersion) then
	error("Incorrect deflate version: must be "..requiredDeflateVersion..", not "..deflate._VERSION)
end

local function bsRight(num, pow)
	return math.floor(num / 2^pow)
end

local function bsLeft(num, pow)
	return math.floor(num * 2^pow)
end

local function bytesToNum(bytes)
	local n = 0
	for k,v in ipairs(bytes) do
		n = bsLeft(n, 8) + v
	end
	if (n > 2147483647) then
		return (n - 4294967296)
	else
		return n
	end
	n = (n > 2147483647) and (n - 4294967296) or n
	return n
end

local function byte_stream(raw)
	local stream = {}
	local curr = 0
	
	function stream:read(n)
		local b = raw:sub(curr + 1, curr + n)
		curr = curr + n
		return b
	end
	
	return stream
end

local function readInt(stream, bps)
	local bytes = {}
	bps = bps or 4
	for i=1,bps do
		bytes[i] = stream:read(1):byte()
	end
	return bytesToNum(bytes)
end

local function readChar(stream, num)
	num = num or 1
	return stream:read(num)
end

local function readByte(stream)
	return stream:read(1):byte()
end

local function getDataIHDR(stream, length)
	local data = {}
	data["width"] = readInt(stream)
	data["height"] = readInt(stream)
	data["bitDepth"] = readByte(stream)
	data["colorType"] = readByte(stream)
	data["compression"] = readByte(stream)
	data["filter"] = readByte(stream)
	data["interlace"] = readByte(stream)
	return data
end

local function getDataIDAT(stream, length, oldData)
	local data = {}
	if (oldData == nil) then
		data.data = readChar(stream, length)
	else
		data.data = oldData.data .. readChar(stream, length)
	end
	return data
end

local function getDataPLTE(stream, length)
	local data = {}
	data["numColors"] = math.floor(length/3)
	data["colors"] = {}
	for i = 1, data["numColors"] do
		data.colors[i] = {
			R = readByte(stream),
			G = readByte(stream),
			B = readByte(stream)
		}
	end
	return data
end

local function extractChunkData(stream)
	local chunkData = {}
	local length
	local type
	local crc

	while type ~= "IEND" do
		length = readInt(stream)
		type = readChar(stream, 4)
		if (type == "IHDR") then
			chunkData[type] = getDataIHDR(stream, length)
		elseif (type == "IDAT") then
			chunkData[type] = getDataIDAT(stream, length, chunkData[type])
		elseif (type == "PLTE") then
			chunkData[type] = getDataPLTE(stream, length)
		else
			readChar(stream, length)
		end
		crc = readChar(stream, 4)
	end

	return chunkData
end

local function makePixel(stream, depth, colorType, palette)
	local bps = math.floor(depth/8) --bits per sample
	local pixelData = { R = 0, G = 0, B = 0, A = 0 }
	local grey
	local index
	local color 

	if colorType == 0 then
		grey = readInt(stream, bps)
		pixelData.R = grey
		pixelData.G = grey
		pixelData.B = grey
		pixelData.A = 255
	elseif colorType == 2 then
		pixelData.R = readInt(stream, bps)
		pixelData.G = readInt(stream, bps)
		pixelData.B = readInt(stream, bps)
		pixelData.A = 255
	elseif colorType == 3 then
		index = readInt(stream, bps)+1
		color = palette.colors[index]
		pixelData.R = color.R
		pixelData.G = color.G
		pixelData.B = color.B
		pixelData.A = 255
	elseif colorType == 4 then
		grey = readInt(stream, bps)
		pixelData.R = grey
		pixelData.G = grey
		pixelData.B = grey
		pixelData.A = readInt(stream, bps)
	elseif colorType == 6 then
		pixelData.R = readInt(stream, bps)
		pixelData.G = readInt(stream, bps)
		pixelData.B = readInt(stream, bps)
		pixelData.A = readInt(stream, bps)
	end

	return pixelData
end

local function bitFromColorType(colorType)
	if colorType == 0 then return 1 end
	if colorType == 2 then return 3 end
	if colorType == 3 then return 1 end
	if colorType == 4 then return 2 end
	if colorType == 6 then return 4 end
	error 'Invalid colortype'
end

local function paethPredict(a, b, c)
	local p = a + b - c
	local varA = math.abs(p - a)
	local varB = math.abs(p - b)
	local varC = math.abs(p - c)

	if varA <= varB and varA <= varC then 
		return a 
	elseif varB <= varC then 
		return b 
	else
		return c
	end
end

local function filterType1(curPixel, lastPixel)
	local lastByte
	local newPixel = {}
	for fieldName, curByte in pairs(curPixel) do
		lastByte = lastPixel and lastPixel[fieldName] or 0
		newPixel[fieldName] = (curByte + lastByte) % 256
	end
	return newPixel
end

local prevPixelRow = {}
local function getPixelRow(stream, depth, colorType, palette, length)
	local pixelRow = {}
	local bpp = math.floor(depth/8) * bitFromColorType(colorType)
	local bpl = bpp*length
	local filterType = readByte(stream)
	
	--[[
	if filterType == 0 then
		for x = 1, length do
			pixelRow[x] = makePixel(stream, depth, colorType, palette)
		end
	elseif filterType == 1 then
		local curPixel
		local lastPixel
		local newPixel
		local lastByte
		for x = 1, length do
			curPixel = makePixel(stream, depth, colorType, palette)
			lastPixel = prevPixelRow[pixelNum]
			newPixel = {}
			for fieldName, curByte in pairs(curPixel) do
				lastByte = lastPixel and lastPixel[fieldName] or 0
				newPixel[fieldName] = (curByte + lastByte) % 256
			end
			pixelRow[x] = newPixel
		end
	else
		error("Unsupported filter type: " .. tostring(filterType))
	end--]]
	
	local curPixel
		local lastPixel
		local newPixel
		local lastByte
		for x = 1, length do
			curPixel = makePixel(stream, depth, colorType, palette)
			lastPixel = prevPixelRow[x]
			newPixel = {}
			for fieldName, curByte in pairs(curPixel) do
				lastByte = lastPixel and lastPixel[fieldName] or 0
				newPixel[fieldName] = (curByte + lastByte) % 256
			end
			pixelRow[x] = newPixel
		end
	
	prevPixelRow = pixelRow

	return pixelRow
end


local function pngImage(path, progCallback, verbose, memSave)
	local stream = byte_stream(path)
	local chunkData
	local imStr
	local width = 0
	local height = 0
	local depth = 0
	local colorType = 0
	local output = {}
	local pixels = {}
	local StringStream
	local function printV(msg)
		if (verbose) then
			print(msg)
		end
	end

	if readChar(stream, 8) ~= "\137\080\078\071\013\010\026\010" then 
		error "Not a png"
	end

	printV("Parsing Chunks...")
	chunkData = extractChunkData(stream)

	width = chunkData.IHDR.width
	height = chunkData.IHDR.height
	depth = chunkData.IHDR.bitDepth
	colorType = chunkData.IHDR.colorType

	printV("Deflating...")
	deflate.inflate_zlib {
		input = chunkData.IDAT.data, 
		output = function(byte) 
			output[#output+1] = string.char(byte) 
		end, 
		disable_crc = true
	}
	StringStream = {
		str = table.concat(output),
		read = function(self, num)
			local toreturn = self.str:sub(1, num)
			self.str = self.str:sub(num + 1, self.str:len())
			return toreturn
		end  
	}
	
	printV("Creating pixelmap...")
	for i = 1, height do
		local pixelRow = getPixelRow(StringStream, depth, colorType, chunkData.PLTE, width)
		if progCallback ~= nil then 
			progCallback(i, height, pixelRow)
		end
		if not memSave then
			pixels[i] = pixelRow
		end
	end

	printV("Done.")
	return {
		width = width,
		height = height,
		depth = depth,
		colorType = colorType,
		pixels = pixels
	}
end

return pngImage]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX9C8ABA273FD4454D88E1B06E62C179F7">
			<Properties>
				<string name="Name">Roact</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX8D60E9BF12C643B69B99F28E2979EA3C">
				<Properties>
					<string name="Name">Libs</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0ADDF915A3624F27869B0AA08AF32C9F">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Button</string>
						<string name="ScriptGuid">{1C90215E-9298-4785-8055-6507FB0F12BC}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local assetDefault = "rbxasset://textures/TerrainTools/button_default.png"
local assetHovered = "rbxasset://textures/TerrainTools/button_hover.png"
local assetPressed = "rbxasset://textures/TerrainTools/button_pressed.png"

local Button = Roact.PureComponent:extend("Button")

function Button:render()
	local props = self.props
	return Roact.createElement("ImageButton", {
		Size = props.Size or UDim2.new(0, 150, 0, 24),
		LayoutOrder = props.LayoutOrder,

		Image =
			props.disabled and assetDefault or
			(props.pressed or self.state.pressed) and assetPressed or
			self.state.hovered and assetHovered or
			assetDefault,
		BackgroundTransparency = 1.0,
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(7, 7, 156, 36),
		AutoButtonColor = false,

		[Roact.Event.InputBegan] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				self:setState({
					hovered = true
				})
			end
		end,

		[Roact.Event.InputEnded] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				self:setState({
					hovered = false
				})
			end
		end,

		[Roact.Event.MouseButton1Down] = function(rbx)
			self:setState({
				pressed = true
			})
		end,

		[Roact.Event.MouseButton1Up] = function(rbx)
			self:setState({
				pressed = false,
			})
		end,

		[Roact.Event.MouseButton1Click] = function(rbx)
			if props.onClick then
				props.onClick()
			end
		end,
	}, {
		ButtonLabel = Roact.createElement("TextLabel", {
			Text = props.labelText or "props.labelText",
			TextColor3 =
				props.disabled and settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.DimmedText) or
				(props.pressed or self.state.pressed) and settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.BrightText) or
				Color3.fromRGB(0, 0, 0),
			BackgroundTransparency = 1.0,
			Size = UDim2.new(1, 0, 1, 0),
			Font = Enum.Font.SourceSans,
			TextSize = 15,
		})
	})
end

return Button]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX48052DC62C4646C4A26AF8361B1A9A8C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Checkbox</string>
						<string name="ScriptGuid">{836BF133-4A62-44C8-9327-43D2E9328959}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local enabledImage = "rbxassetid://2144125664"

local function Checkbox(props)
	-- nil == indeterminate
	local value = props.value
	local setValue = props.setValue

	return Roact.createElement("ImageButton", {
		LayoutOrder = props.LayoutOrder,
		Size = props.Size or UDim2.new(0, 20, 0, 20),
		BackgroundTransparency = 1.0,

		[Roact.Event.MouseButton1Click] = function(rbx)
			-- nil -> true, false -> true, true -> false
			if setValue then
				setValue(value ~= true)
			end
		end,
	}, {
		Frame = Roact.createElement("Frame", {
			Size = UDim2.new(0, 15, 0, 15),
			AnchorPoint = Vector2.new(0.5, 0.5),
			Position = UDim2.new(0.5, 0, 0.5, 0),
			BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.InputFieldBackground),
			BorderSizePixel = 0,
		}, {
			CheckImage = Roact.createElement("ImageLabel", {
				Size = UDim2.new(0, 15, 0, 15),
				Image = value and enabledImage or "",
				ImageColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.LinkText),
				BackgroundTransparency = value == nil and 0.0 or 1.0,
				BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.InfoText),
				BorderSizePixel = 0,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.new(0.5, 0, 0.5, 0),
			})
		})
	})
end

return Checkbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8BEF2ABDD36A4F52A1EEF934191480AA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Constants</string>
						<string name="ScriptGuid">{26FC015C-6A4A-4E05-BE2B-4CFB13E3A2C8}</string>
						<ProtectedString name="Source"><![CDATA[return {
	titlebarHeight = 27,
	titlebarColor = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Titlebar),
	black = Color3.fromRGB(0, 0, 0),
	white = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainText),
}]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX63319AE42E4146628A81433239107783">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FitChildren</string>
						<string name="ScriptGuid">{522FE170-4994-4C7B-86A3-36994BFC0777}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local function join(a, b)
	local t = {}
	for k,v in pairs(a) do
		t[k] = v
	end
	for k,v in pairs(b) do
		t[k] = v
	end
	return t
end

local function applySize(udim, value)
	if udim.Scale == 0 then
		return UDim.new(0, value)
	else
		return udim
	end
end

local function FitChildrenFactory(name)
	local FitChildren = Roact.Component:extend("FitChildren("..name..")")

	function FitChildren:_updateSize()
		local size = self.layout.AbsoluteContentSize
		if self.padding then
			local p = self.padding
			size = size + Vector2.new(
				p.PaddingLeft.Offset + p.PaddingRight.Offset,
				p.PaddingTop.Offset + p.PaddingBottom.Offset
			)
		end
		self.rbx.Size = UDim2.new(applySize(self.rbx.Size.X, size.X), applySize(self.rbx.Size.Y, size.Y))
		if self.rbx.ClassName == 'ScrollingFrame' then
			self.rbx.CanvasSize = UDim2.new(applySize(self.rbx.CanvasSize.X, size.X), applySize(self.rbx.CanvasSize.Y, size.Y))
		end
	end

	function FitChildren:_childAdded(inst)
		if inst:IsA("UILayout") then
			self.layout = inst
			self:_updateSize()
			self.sizeChangedConn = inst:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
				self:_updateSize()
			end)
		elseif inst.ClassName == 'UIPadding' then
			self.padding = inst
			self:_updateSize()
			self.paddingChangedConn = inst.Changed:Connect(function()
				self:_updateSize()
			end)
		end
	end

	function FitChildren:render()
		local props = self.props
		return Roact.createElement(name, join(props, {
			[Roact.Ref] = function(rbx)
				if rbx then
					self.rbx = rbx
					self.childAdded = rbx.ChildAdded:Connect(function(inst)
						self:_childAdded(inst)
					end)
					for _,child in pairs(rbx:GetChildren()) do
						self:_childAdded(child)
					end
				else
					self.rbx = nil
					self.childAdded:Disconnect()
					if self.sizeChangedConn then
						self.sizeChangedConn:Disconnect()
					end
					if self.paddingChangedConn then
						self.paddingChangedConn:Disconnect()
					end
				end
			end,
		}))
	end

	return FitChildren
end

local FitChildren = {}
FitChildren.Frame = FitChildrenFactory("Frame")
FitChildren.ScrollingFrame = FitChildrenFactory("ScrollingFrame")
return FitChildren]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX1DC4B0FE536B4BC49D089C82FABD0886">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Label</string>
						<string name="ScriptGuid">{A97C0F8C-86E8-42E6-B407-B5B9447F7112}</string>
						<ProtectedString name="Source"><![CDATA[local TextService = game:GetService("TextService")

local Roact = require(script.Parent.Parent.Roact)

local function Label(props)
	local text = props.labelText or "props.labelText"
	local size = props.textSize or 15
	local font = props.font or Enum.Font.SourceSans
	local maxSize = props.maxSize or Vector2.new(10000, 10000)
	local padding = props.padding or 0
	if typeof(padding) == 'number' then
		padding = Vector2.new(1, 1) * padding
	end

	local bounds = TextService:GetTextSize(text, size, font, maxSize)

	return Roact.createElement("TextLabel", {
		LayoutOrder = props.LayoutOrder,
		Size = UDim2.new(0, bounds.X + padding.X * 2, 0, bounds.Y + padding.Y * 2),

		Text = text,
		TextSize = size,
		Font = font,

		TextColor3 = props.textColor or Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 1.0,
	})
end

return Label]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7BCB4A7C48C04A048D31FBD28BB8AC1D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Property</string>
						<string name="ScriptGuid">{958231BA-A947-4B68-844C-95676111433F}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Constants = require(script.Parent.Constants)
local FitChildren = require(script.Parent.FitChildren)

local function Property(props)
	local pSize = props.propertyLabelSize or Vector2.new(180, 24)
	return Roact.createElement(FitChildren.Frame, {
		Size = UDim2.new(1, 0, 0, pSize.Y),
		LayoutOrder = props.LayoutOrder,
		BackgroundTransparency = 1.0,
	}, {
		PropertyLabel = Roact.createElement("Frame", {
			Size = UDim2.new(0, pSize.X, 1, 0),
			BorderSizePixel = 1,
			BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border),
			BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground),
		}, {
			Contents = Roact.createElement("TextLabel", {
				Size = UDim2.new(1, -8, 1, 0),
				Position = UDim2.new(0, 8, 0, 0),
				Text = props.propertyName or "props.propertyName",
				Font = Enum.Font.SourceSans,
				TextSize = 14,
				TextColor3 = Constants.white,
				TextXAlignment = Enum.TextXAlignment.Left,
				BackgroundTransparency = 1.0,
			}),
		}),
		PropertyContainer = Roact.createElement("Frame", {
			Size = UDim2.new(1, -pSize.X, 1, 0),
			BorderSizePixel = 1,
			BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border),
			Position = UDim2.new(0, pSize.X, 0, 0),
			BackgroundColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.MainBackground),
		}, {
			Contents = Roact.oneChild(props[Roact.Children])
		})
	})
end

return Property]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB01AAA7952C14AF590B0D522D98F80FE">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioButtons</string>
						<string name="ScriptGuid">{B04ED390-8AB2-4CDD-BF3D-949E851B912D}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Button = require(script.Parent.Button)
local FitChildren = require(script.Parent.FitChildren)

local function RadioButtons(props)
	local children = {}
	children.UIGridLayout = Roact.createElement("UIGridLayout", {
		SortOrder = Enum.SortOrder.LayoutOrder,
		CellPadding = UDim2.new(0, 3, 0, 3),
		CellSize = props.buttonSize or UDim2.new(0, 140, 0, 24),
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		VerticalAlignment = Enum.VerticalAlignment.Center,
	})
	children.UIPadding = Roact.createElement("UIPadding", {
		PaddingLeft = UDim.new(0, 4),
		PaddingRight = UDim.new(0, 4),
		PaddingTop = UDim.new(0, 4),
		PaddingBottom = UDim.new(0, 4),
	})
	for i = 1, #props.buttons do
		local button = props.buttons[i]
		children[button] = Roact.createElement(Button, {
			LayoutOrder = i,
			Size = props.buttonSize or UDim2.new(0, 150, 0, 24),

			labelText = button,
			pressed = props.selected == i,

			onClick = function()
				if props.onSelect then
					props.onSelect(i, button)
				end
			end,
		})
	end

	return Roact.createElement(FitChildren.Frame, {
		LayoutOrder = props.LayoutOrder or 1;
		AnchorPoint = props.AnchorPoint or Vector2.new(0, 0);
		Position = props.Position or UDim2.new(0, 0, 0, 0);
		Size = props.size or UDim2.new(1, 0, 0, 0),
		BackgroundTransparency = 1.0,
	}, children)
end

return RadioButtons]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6472655768094B3C86CA9722C9BBE51E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Section</string>
						<string name="ScriptGuid">{75CBB890-E395-4537-8965-F85AC71CFA32}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Constants = require(script.Parent.Constants)
local FitChildren = require(script.Parent.FitChildren)

local Section = Roact.PureComponent:extend("Section")

function Section:render()
	local props = self.props

	return Roact.createElement(FitChildren.Frame, {
		BackgroundTransparency = 1.0,
		Size = UDim2.new(1, 0, 0, 0),
		LayoutOrder = props.LayoutOrder,
	}, {
		UIListLayout = Roact.createElement("UIListLayout", {
			SortOrder = Enum.SortOrder.LayoutOrder,
		}),
		Titlebar = Roact.createElement("ImageButton", {
			LayoutOrder = 1,
			AutoButtonColor = false,
			BorderSizePixel = 1,
			BorderColor3 = Color3.fromRGB(34, 34, 34),
			Size = UDim2.new(1, 0, 0, Constants.titlebarHeight),
			BackgroundColor3 = Constants.titlebarColor,

			[Roact.Event.Activated] = function(rbx)
				local now = tick()
				if now - (self.lastClickTime or 0) < 0.5 then
					self.lastClickTime = 0
					self:setState({
						minimized = not self.state.minimized,
					})
				else
					self.lastClickTime = now
				end
			end,
		}, {
			TitleLabel = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1.0,
				Font = Enum.Font.SourceSansBold,
				TextSize = 15,
				TextColor3 = Constants.white,
				TextXAlignment = Enum.TextXAlignment.Left,
				Text = props.titleText or "props.titleText",
				Position = UDim2.new(0, Constants.titlebarHeight, 0, 0),
				Size = UDim2.new(1, -Constants.titlebarHeight, 1, 0),
			}),
			Minimize = Roact.createElement("ImageButton", {
				Image = self.state.minimized and 'rbxassetid://2144126493' or 'rbxassetid://2144126139',
				Size = UDim2.new(0, 10, 0, 10),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.new(0, Constants.titlebarHeight * 0.5, 0, Constants.titlebarHeight * 0.5),
				BackgroundTransparency = 1.0,

				[Roact.Event.Activated] = function(rbx)
					self:setState({
						minimized = not self.state.minimized,
					})
				end,
			})
		}),
		Contents = Roact.createElement(FitChildren.Frame, {
			LayoutOrder = 2,
			BackgroundTransparency = 1.0,
			Size = UDim2.new(1, 0, 0, 0),
			Visible = not self.state.minimized,
		}, props[Roact.Children]),
	})
end

return Section]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX16403237110A46E89F613B33481783B5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Slider</string>
						<string name="ScriptGuid">{01A0D3A1-9B58-4539-8B11-9803357DE794}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)

local sliderWidth = 10

local Slider = Roact.PureComponent:extend("Slider")

local function Round(n, r)
	if not r then r = 1 end
	return math.floor((n / r) + 0.5) * r
end

-- props:
-- float value
-- float ticks
-- void setValue(float)
function Slider:render()
	local props = self.props
	local max = props.sliderMax or 1
	local min = props.sliderMin or 0
	local snap = props.sliderSnap or 0.001
	return Roact.createElement("ImageButton", {
		Size = props.Size,
		Position = props.Position,
		LayoutOrder = props.LayoutOrder,
		BackgroundTransparency = 1.0,

		[Roact.Event.InputBegan] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				self.startPos = input.Position
				self:setState({
					pressed = true,
				})
				local mousePos = Vector2.new(
					input.Position.X,
					input.Position.Y
				)
				local rawVal = math.clamp((mousePos.x - rbx.Bar.Container.AbsolutePosition.x) / rbx.Bar.Container.AbsoluteSize.x, 0, 1)
				local value = Round((rawVal * max) + min, snap)
				if props.setValue then
					props.setValue(value)
				end
			end
		end,
		[Roact.Event.InputChanged] = function(rbx, input)
			if self.startPos and input.UserInputType == Enum.UserInputType.MouseMovement then
				local mousePos = Vector2.new(
					input.Position.X,
					input.Position.Y
				)
				local rawVal = math.clamp((mousePos.x - rbx.Bar.Container.AbsolutePosition.x) / rbx.Bar.Container.AbsoluteSize.x, 0, 1)
				local value = Round((rawVal * max) + min, snap)
				if props.setValue then
					props.setValue(value)
				end
			end
		end,
		[Roact.Event.InputEnded] = function(rbx, input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				self.startPos = nil
				self:setState({
					pressed = false,
				})
			end
		end,
	}, {
		Bar = Roact.createElement("Frame", {
			Position = UDim2.new(0.5, 0, 0.5, 0),
			AnchorPoint = Vector2.new(0.5, 0.5),
			Size = UDim2.new(1, -6, 0, 2),
			BackgroundColor3 = Color3.fromRGB(85, 85, 85),
			BorderSizePixel = 0,
		}, {
			Container = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Position = UDim2.new(0,sliderWidth/2,0,0),
				Size = UDim2.new(1,-sliderWidth,1,0)
			}, {
				Slider = Roact.createElement("Frame", {
					AnchorPoint = Vector2.new(.5, .5),
					Position = UDim2.new(math.clamp((props.value - min) / max or .5,0,1), 0, .5, 0),
					Size = UDim2.new(0, sliderWidth, 0, 20),
					BorderColor3 = self.state.pressed and Color3.fromRGB(0,0,0) or Color3.fromRGB(58, 58, 58),
					BackgroundColor3 = self.state.pressed and Color3.fromRGB(99,99,99) or Color3.fromRGB(66, 66, 66),
				}),
			}),
		})
	})
end

return Slider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCF64EB4EC670490FB24D54C8F0EBA2AA">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Textbox</string>
						<string name="ScriptGuid">{3847CAFF-A5A9-4393-8D33-09231DF57DE6}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Constants = require(script.Parent.Constants)

local Textbox = Roact.Component:extend("Textbox")

function Textbox:render()
	local props = self.props
	local value = props.value
	local setValue = props.setValue
	local focusLost = props.focusLost
	local onSubmit = props.onSubmit
	local focused = props.focused

	return Roact.createElement("Frame", {
		Size = props.Size or UDim2.new(0, 300, 0, 20),
		Position = props.Position,
		LayoutOrder = props.LayoutOrder,
		BackgroundColor3 = focused and Color3.fromRGB(34, 34, 34) or Color3.fromRGB(46, 46, 46),
		BorderColor3 = Color3.fromRGB(34, 34, 34),
		BorderSizePixel = focused and 1 or 0,
	}, {
		TextInput = Roact.createElement("TextBox", {
			Font = Enum.Font.SourceSans,
			TextSize = 15,
			BackgroundTransparency = 1.0,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Center,
			Size = UDim2.new(1, -4, 1, -2),
			Position = UDim2.new(0, 4, 0, 0),
			ClipsDescendants = true,
			ClearTextOnFocus = props.ClearTextOnFocus,
			Text = tostring(value),
			TextColor3 = Color3.new(1,1,1),
			
			[Roact.Event.Focused] = props.onFocused,

			[Roact.Event.FocusLost] = function(rbx, enterPressed)
				if enterPressed then
					if onSubmit then
						onSubmit(rbx.Text)
					end
				else
					if focusLost then
						focusLost(rbx.Text)
					end
				end
				rbx.Text = tostring(self.props.value)
			end,

			[Roact.Change.Text] = function(rbx)
				if self.debounce then
					return
				end
				self.debounce = true
				local oldText = self.props.value
				local newText = rbx.Text
				if setValue and newText ~= oldText then
					setValue(newText)
				end
				self.debounce = false
			end,
		})
	})
end

return Textbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAAC5E358A11A48FD949C8D643FEA7F55">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init</string>
						<string name="ScriptGuid">{A814A96A-0D77-4F99-B119-F21ECB778E23}</string>
						<ProtectedString name="Source"><![CDATA[local modules = {}

for _,module in pairs(script.Parent:GetChildren()) do
	if module ~= script and module:IsA("ModuleScript") then
		modules[module.Name] = require(module)
	end
end

return modules
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0BB523D98F01483CAC8E1F9140E3A69C">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">RadioListButtons</string>
						<string name="ScriptGuid">{0B64AC1C-998C-413C-9D9C-47774F84F94B}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Button = require(script.Parent.Button)
local FitChildren = require(script.Parent.FitChildren)

local function RadioButtons(props)
	local children = {}
	children.UIListLayout = Roact.createElement("UIListLayout", {
		SortOrder = Enum.SortOrder.LayoutOrder,
		Padding = UDim.new(0,2);
		HorizontalAlignment = Enum.HorizontalAlignment.Left,
	})
	children.UIPadding = Roact.createElement("UIPadding", {
		PaddingLeft = UDim.new(0, 4),
		PaddingRight = UDim.new(0, 4),
		PaddingTop = UDim.new(0, 4),
		PaddingBottom = UDim.new(0, 4),
	})
	for i = 1, #props.buttons do
		local button = props.buttons[i]
		children[button] = Roact.createElement(Button, {
			LayoutOrder = i,
			Size = props.buttonSize or UDim2.new(0, 140, 0, 24),

			labelText = button,
			pressed = props.selected == i,

			onClick = function()
				if props.onSelect then
					props.onSelect(i, button)
				end
			end,
		})
	end

	return Roact.createElement(FitChildren.Frame, {
		LayoutOrder = props.LayoutOrder or 1;
		Size = props.size or UDim2.new(1, 0, 0, 0),
		BackgroundTransparency = 1.0,
	}, children)
end

return RadioButtons]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8FED411268734AD0871C2A9CA1EC59D0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Titlebar</string>
						<string name="ScriptGuid">{7B345576-B948-4F37-9175-C4B28EF3F04D}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Constants = require(script.Parent.Constants)
local FitChildren = require(script.Parent.FitChildren)

local function Titlebar(props)
	return Roact.createElement(FitChildren.Frame, {
		BackgroundTransparency = 1;
		Size = UDim2.new(1, 0, 0, Constants.titlebarHeight);
		LayoutOrder = props.LayoutOrder
	}, {
		Titlebar = Roact.createElement("Frame", {
			LayoutOrder = 1;
			BorderSizePixel = 1;
			BorderColor3 = settings().Studio.Theme:GetColor(Enum.StudioStyleGuideColor.Border);
			Size = UDim2.new(1, 0, 0, Constants.titlebarHeight);
			BackgroundColor3 = Constants.titlebarColor;
		}, {
			TitleLabel = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1;
				Font = Enum.Font.SourceSansBold;
				TextSize = 15;
				TextColor3 = Constants.white;
				TextXAlignment = Enum.TextXAlignment.Left;
				Text = props.titleText or "props.titleText";
				Position = UDim2.new(0, Constants.titlebarHeight, 0, 0);
				Size = UDim2.new(1, -Constants.titlebarHeight, 1, 0);
			});
		});
	});
end

return Titlebar]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX33DD075C9BC34E95BF378A2CF4795BBD">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Roact</string>
					<string name="ScriptGuid">{D9BD402A-BEF6-4B03-8074-B19F12040135}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local Change = require(script.Change)
local Component = require(script.Component)
local Core = require(script.Core)
local createElement = require(script.createElement)
local createRef = require(script.createRef)
local Event = require(script.Event)
local GlobalConfig = require(script.GlobalConfig)
local Instrumentation = require(script.Instrumentation)
local oneChild = require(script.oneChild)
local PureComponent = require(script.PureComponent)
local Reconciler = require(script.Reconciler)
local ReconcilerCompat = require(script.ReconcilerCompat)

--[[
	A utility to copy one module into another, erroring if there are
	overlapping keys.

	Any keys that begin with an underscore are considered private.
]]
local function apply(target, source)
	for key, value in pairs(source) do
		if target[key] ~= nil then
			error(("Roact: key %q was overridden!"):format(key), 2)
		end

		-- Don't add internal values
		if not key:find("^_") then
			target[key] = value
		end
	end
end

local Roact = {}

apply(Roact, Core)
apply(Roact, Reconciler)
apply(Roact, ReconcilerCompat)

apply(Roact, {
	Change = Change,
	Component = Component,
	createElement = createElement,
	createRef = createRef,
	Event = Event,
	oneChild = oneChild,
	PureComponent = PureComponent,
})

apply(Roact, {
	setGlobalConfig = GlobalConfig.set,
	getGlobalConfigValue = GlobalConfig.getValue,
})

apply(Roact, {
	-- APIs that may change in the future
	UNSTABLE = {
		getCollectedStats = Instrumentation.getCollectedStats,
		clearCollectedStats = Instrumentation.clearCollectedStats,
	}
})

return Roact]]></ProtectedString>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX00BB55128E2D4D6D8431F81EC22E9D81">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Symbol</string>
						<string name="ScriptGuid">{89FB604E-34E1-4DCB-B2AE-9E0661F04EC3}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

--[[
	Create an unnamed Symbol. Usually, you should create a named Symbol using
	Symbol.named(name)
]]
function Symbol.unnamed()
	local self = newproxy(true)

	getmetatable(self).__tostring = function()
		return "Unnamed Symbol"
	end

	return self
end

return Symbol]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX699DA90798F84FAE98139A2B8A524865">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core</string>
						<string name="ScriptGuid">{ED9CEEF6-F054-4715-94C9-34605E7660D5}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Provides a set of markers used for annotating data in Roact.
]]

local Symbol = require(script.Parent.Symbol)

local Core = {}

-- Marker used to specify children of a node.
Core.Children = Symbol.named("Children")

-- Marker used to specify a callback to receive the underlying Roblox object.
Core.Ref = Symbol.named("Ref")

-- Marker used to specify that a component is a Roact Portal.
Core.Portal = Symbol.named("Portal")

-- Marker used to specify that the value is nothing, because nil cannot be stored in tables.
Core.None = Symbol.named("None")

-- Marker used to specify that the table it is present within is a component.
Core.Element = Symbol.named("Element")

return Core]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4014707F04E54A06B76B75D21FC718F0">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">GlobalConfig</string>
						<string name="ScriptGuid">{10FCC359-6061-43BE-B039-8F6F172DCB50}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX62BF96224FBF4721B9E2E59CC2917A13">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createRef</string>
						<string name="ScriptGuid">{46872B8C-7062-419E-9AF8-F45F25390BCF}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Provides an API for acquiring a reference to a reified object. This
	API is designed to mimic React 16.3's createRef API.

	See:
	* https://reactjs.org/docs/refs-and-the-dom.html
	* https://reactjs.org/blog/2018/03/29/react-v-16-3.html#createref-api
]]

local refMetatable = {
	__tostring = function(self)
		return ("RoactReference(%s)"):format(tostring(self.current))
	end,
}

return function()
	return setmetatable({
		current = nil,
	}, refMetatable)
end]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF6C5B2964B6F43AC993F34238B338A93">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Component</string>
						<string name="ScriptGuid">{FFC064C0-B928-4341-BD58-543A5BF38E00}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	The base implementation of a stateful component in Roact.

	Stateful components handle most of their own mounting and reconciliation
	process. Many of the private methods here are invoked by the reconciler.

	Stateful components expose a handful of lifecycle events:
	- didMount
	- willUnmount
	- willUpdate
	- didUpdate
	- (static) getDerivedStateFromProps

	These lifecycle events line up with their semantics in React, and more
	information (and a diagram) is available in the Roact documentation.
]]

local Reconciler = require(script.Parent.Reconciler)
local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)
local Instrumentation = require(script.Parent.Instrumentation)

local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)

local Component = {}

-- Locally cache tick so we can minimize impact of calling it for instrumentation
local tick = tick

Component.__index = Component

--[[
	Merge any number of dictionaries into a new dictionary, overwriting keys.

	If a value of `Core.None` is encountered, the key will be removed instead.
	This is necessary because Lua doesn't differentiate between a key being
	missing and a key being set to nil.
]]
local function merge(...)
	local result = {}

	for i = 1, select("#", ...) do
		local entry = select(i, ...)

		for key, value in pairs(entry) do
			if value == Core.None then
				result[key] = nil
			else
				result[key] = value
			end
		end
	end

	return result
end

--[[
	Create a new stateful component.

	Not intended to be a general OO implementation, this function only intends
	to let users extend Component and PureComponent.

	Instead of using inheritance, use composition and props to extend
	components.
]]
function Component:extend(name)
	assert(type(name) == "string", "A name must be provided to create a Roact Component")

	local class = {}

	for key, value in pairs(self) do
		-- We don't want users using 'extend' to create component inheritance
		-- see https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class.__index = class

	setmetatable(class, {
		__tostring = function(self)
			return name
		end
	})

	function class._new(props, context)
		local self = {}

		-- When set to a value, setState will fail, using the given reason to
		-- create a detailed error message.
		-- You can see a list of reasons in invalidSetStateMessages.
		self._setStateBlockedReason = nil

		if class.defaultProps == nil then
			self.props = props
		else
			self.props = merge(class.defaultProps, props)
		end

		self._context = {}

		-- Shallow copy all context values from our parent element.
		if context then
			for key, value in pairs(context) do
				self._context[key] = value
			end
		end

		setmetatable(self, class)

		-- Call the user-provided initializer, where state and _props are set.
		if class.init then
			self._setStateBlockedReason = "init"
			class.init(self, props)
			self._setStateBlockedReason = nil
		end

		-- The user constructer might not set state, so we can.
		if not self.state then
			self.state = {}
		end

		if class.getDerivedStateFromProps then
			local partialState = class.getDerivedStateFromProps(props, self.state)

			if partialState then
				self.state = merge(self.state, partialState)
			end
		end

		return self
	end

	return class
end

--[[
	render is intended to describe what a UI should look like at the current
	point in time.

	The default implementation throws an error, since forgetting to define
	render is usually a mistake.

	The simplest implementation for render is:

		function MyComponent:render()
			return nil
		end

	You should explicitly return nil from functions in Lua to avoid edge cases
	related to none versus nil.
]]
function Component:render()
	local message = (
		"The component %q is missing the 'render' method.\n" ..
		"render must be defined when creating a Roact component!"
	):format(
		tostring(getmetatable(self))
	)

	error(message, 0)
end

--[[
	Used to tell Roact whether this component *might* need to be re-rendered
	given a new set of props and state.

	This method is an escape hatch for when the Roact element creation and
	reconciliation algorithms are not fast enough for specific cases. Poorly
	written shouldUpdate methods *will* cause hard-to-trace bugs.

	If you're thinking of writing a shouldUpdate function, consider using
	PureComponent instead, which provides a good implementation given that your
	data is immutable.

	This function must be faster than the render method in order to be a
	performance improvement.
]]
function Component:shouldUpdate(newProps, newState)
	return true
end

--[[
	Applies new state to the component.

	partialState may be one of two things:
	- A table, which will be merged onto the current state.
	- A function, returning a table to merge onto the current state.

	The table variant generally looks like:

		self:setState({
			foo = "bar",
		})

	The function variant generally looks like:

		self:setState(function(prevState, props)
			return {
				foo = prevState.count + 1,
			})
		end)

	The function variant may also return nil in the callback, which allows Roact
	to cancel updating state and abort the render.

	Future versions of Roact will potentially batch or delay state merging, so
	any state updates that depend on the current state should use the function
	variant.
]]
function Component:setState(partialState)
	-- If setState was disabled, we should check for a detailed message and
	-- display it.
	if self._setStateBlockedReason ~= nil then
		local messageSource = invalidSetStateMessages[self._setStateBlockedReason]

		if messageSource == nil then
			messageSource = invalidSetStateMessages["default"]
		end

		-- We assume that each message has a formatting placeholder for a component name.
		local formattedMessage = string.format(messageSource, tostring(getmetatable(self)))

		error(formattedMessage, 2)
	end

	-- If the partial state is a function, invoke it to get the actual partial state.
	if type(partialState) == "function" then
		partialState = partialState(self.state, self.props)

		-- If partialState is nil, abort the render.
		if partialState == nil then
			return
		end
	end

	local newState = merge(self.state, partialState)
	self:_update(nil, newState)
end

--[[
	Returns the current stack trace for this component, or nil if the
	elementTracing configuration flag is set to false.
]]
function Component:getElementTraceback()
	return self._handle._element.source
end

--[[
	Notifies the component that new props and state are available. This function
	is invoked by the reconciler.

	If shouldUpdate returns true, this method will trigger a re-render and
	reconciliation step.
]]
function Component:_update(newProps, newState)
	self._setStateBlockedReason = "shouldUpdate"

	local doUpdate
	if GlobalConfig.getValue("componentInstrumentation") then
		local startTime = tick()

		doUpdate = self:shouldUpdate(newProps or self.props, newState or self.state)

		local elapsed = tick() - startTime
		Instrumentation.logShouldUpdate(self._handle, doUpdate, elapsed)
	else
		doUpdate = self:shouldUpdate(newProps or self.props, newState or self.state)
	end

	self._setStateBlockedReason = nil

	if doUpdate then
		self:_forceUpdate(newProps, newState)
	end
end

--[[
	Forces the component to re-render itself and its children.

	This is essentially the inner portion of _update.

	newProps and newState are optional.
]]
function Component:_forceUpdate(newProps, newState)
	-- Compute new derived state.
	-- Get the class - getDerivedStateFromProps is static.
	local class = getmetatable(self)

	-- If newProps are passed, compute derived state and default props
	if newProps then
		if class.getDerivedStateFromProps then
			local derivedState = class.getDerivedStateFromProps(newProps, newState or self.state)

			-- getDerivedStateFromProps can return nil if no changes are necessary.
			if derivedState ~= nil then
				newState = merge(newState or self.state, derivedState)
			end
		end

		if class.defaultProps then
			-- We only allocate another prop table if there are props that are
			-- falling back to their default.
			local replacementProps

			for key in pairs(class.defaultProps) do
				if newProps[key] == nil then
					replacementProps = merge(class.defaultProps, newProps)
					break
				end
			end

			if replacementProps then
				newProps = replacementProps
			end
		end
	end

	if self.willUpdate then
		self._setStateBlockedReason = "willUpdate"
		self:willUpdate(newProps or self.props, newState or self.state)
		self._setStateBlockedReason = nil
	end

	local oldProps = self.props
	local oldState = self.state

	if newProps then
		self.props = newProps
	end

	if newState then
		self.state = newState
	end

	self._setStateBlockedReason = "render"

	local newChildElement
	if GlobalConfig.getValue("componentInstrumentation") then
		local startTime = tick()

		newChildElement = self:render()

		local elapsed = tick() - startTime
		Instrumentation.logRenderTime(self._handle, elapsed)
	else
		newChildElement = self:render()
	end

	self._setStateBlockedReason = nil

	self._setStateBlockedReason = "reconcile"
	if self._handle._child ~= nil then
		-- We returned an element during our last render, update it.
		self._handle._child = Reconciler._reconcileInternal(
			self._handle._child,
			newChildElement
		)
	elseif newChildElement then
		-- We returned nil during our last render, construct a new child.
		self._handle._child = Reconciler._mountInternal(
			newChildElement,
			self._handle._parent,
			self._handle._key,
			self._context
		)
	end
	self._setStateBlockedReason = nil

	if self.didUpdate then
		self:didUpdate(oldProps, oldState)
	end
end

--[[
	Initializes the component instance and attaches it to the given
	instance handle, created by Reconciler._mount.
]]
function Component:_mount(handle)
	self._handle = handle

	self._setStateBlockedReason = "render"

	local virtualTree
	if GlobalConfig.getValue("componentInstrumentation") then
		local startTime = tick()

		virtualTree = self:render()

		local elapsed = tick() - startTime
		Instrumentation.logRenderTime(self._handle, elapsed)
	else
		virtualTree = self:render()
	end

	self._setStateBlockedReason = nil

	if virtualTree then
		self._setStateBlockedReason = "reconcile"
		handle._child = Reconciler._mountInternal(
			virtualTree,
			handle._parent,
			handle._key,
			self._context
		)
		self._setStateBlockedReason = nil
	end

	if self.didMount then
		self:didMount()
	end
end

--[[
	Destructs the component and invokes all necessary lifecycle methods.
]]
function Component:_unmount()
	local handle = self._handle

	if self.willUnmount then
		self._setStateBlockedReason = "willUnmount"
		self:willUnmount()
		self._setStateBlockedReason = nil
	end

	-- Stateful components can return nil from render()
	if handle._child then
		Reconciler.unmount(handle._child)
	end

	self._handle = nil
end

return Component
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD0531A0763BF4376B8AA2968D0514C82">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">createElement</string>
						<string name="ScriptGuid">{EB94289A-FFEB-470E-8AE9-8315EA826C38}</string>
						<ProtectedString name="Source"><![CDATA[local Core = require(script.Parent.Core)
local GlobalConfig = require(script.Parent.GlobalConfig)

--[[
	Creates a new Roact element of the given type.

	Does not create any concrete objects.
]]
local function createElement(elementType, props, children)
	if elementType == nil then
		error(("Expected elementType as an argument to createElement!"), 2)
	end

	props = props or {}

	if children then
		if props[Core.Children] ~= nil then
			warn("props[Children] was defined but was overridden by third parameter to createElement!")
		end

		props[Core.Children] = children
	end

	local element = {
		type = Core.Element,
		component = elementType,
		props = props,
	}

	if GlobalConfig.getValue("elementTracing") then
		element.source = ("\n%s\n"):format(debug.traceback())
	end

	return element
end

return createElement]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9FDBE91A702647AE95C698FA78575B43">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SingleEventManager</string>
						<string name="ScriptGuid">{2422314D-6B1C-4166-8319-4D3C786CE365}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	An interface to have one event listener at a time on an event.

	One listener can be registered per SingleEventManager/Instance/Event triple.

	For example:

		myManager:connect(myPart, "Touched", touchedListener)
		myManager:connect(myPart, "Touched", otherTouchedListener)

	If myPart is touched, only `otherTouchedListener` will fire, because the
	first listener was disconnected during the second connect call.

	The hooks provided by SingleEventManager pass the associated Roblox object
	as the first parameter to the callback. This differs from normal
	Roblox events.
]]

local SingleEventManager = {}

SingleEventManager.__index = SingleEventManager

local function createHook(rbx, key, method)
	local hook = {
		method = method,
		connection = rbx[key]:Connect(function(...)
			method(rbx, ...)
		end)
	}

	return hook
end

local function createChangeHook(rbx, key, method)
	local hook = {
		method = method,
		connection = rbx:GetPropertyChangedSignal(key):Connect(function(...)
			method(rbx, ...)
		end)
	}

	return hook
end

local function formatChangeKey(key)
	return ("!PropertyChangeEvent:%s"):format(key)
end

function SingleEventManager.new()
	local self = {}

	self._hookCache = {}

	setmetatable(self, SingleEventManager)

	return self
end

function SingleEventManager:connect(rbx, key, method)
	local rbxHooks = self._hookCache[rbx]

	if rbxHooks then
		local existingHook = rbxHooks[key]

		if existingHook then
			if existingHook.method == method then
				return
			end

			existingHook.connection:Disconnect()
		end

		rbxHooks[key] = createHook(rbx, key, method)
	else
		rbxHooks = {}
		rbxHooks[key] = createHook(rbx, key, method)

		self._hookCache[rbx] = rbxHooks
	end
end

function SingleEventManager:connectProperty(rbx, key, method)
	local rbxHooks = self._hookCache[rbx]
	local formattedKey = formatChangeKey(key)

	if rbxHooks then
		local existingHook = rbxHooks[formattedKey]

		if existingHook then
			if existingHook.method == method then
				return
			end

			existingHook.connection:Disconnect()
		end

		rbxHooks[formattedKey] = createChangeHook(rbx, key, method)
	else
		rbxHooks = {}
		rbxHooks[formattedKey] = createChangeHook(rbx, key, method)

		self._hookCache[rbx] = rbxHooks
	end
end

function SingleEventManager:disconnect(rbx, key)
	local rbxHooks = self._hookCache[rbx]

	if not rbxHooks then
		return
	end

	local existingHook = rbxHooks[key]

	if not existingHook then
		return
	end

	existingHook.connection:Disconnect()
	rbxHooks[key] = nil

	if next(rbxHooks) == nil then
		self._hookCache[rbx] = nil
	end
end

function SingleEventManager:disconnectProperty(rbx, key)
	self:disconnect(rbx, formatChangeKey(key))
end

function SingleEventManager:disconnectAll(rbx)
	local rbxHooks = self._hookCache[rbx]

	if not rbxHooks then
		return
	end

	for _, hook in pairs(rbxHooks) do
		hook.connection:Disconnect()
	end

	self._hookCache[rbx] = nil
end

return SingleEventManager
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA7E360FE77DF4AC093ABEE43185E0582">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PureComponent</string>
						<string name="ScriptGuid">{84D55366-5254-40F7-8E46-A7AE2299F92D}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX46C96F28111F4A09930DBB702EFCD4F7">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Instrumentation</string>
						<string name="ScriptGuid">{EE3EBF48-81A3-4357-8159-789C7449717A}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	An optional instrumentation layer that the reconciler calls into to record
	various events.

	Tracks a number of stats, including:
		Recorded stats:
		- Render count by component
		- Update request count by component
		- Actual update count by component
		- shouldUpdate returned true count by component
		- Time taken to run shouldUpdate
		- Time taken to render by component
		Derivable stats (for profiling manually or with a future tool):
		- Average render time by component
		- Percent of total render time by component
		- Percent of time shouldUpdate returns true
		- Average shouldUpdate time by component
		- Percent of total shouldUpdate time by component
]]

local Instrumentation = {}

local componentStats = {}

--[[
	Determines name of component from the given instance handle and returns a
	stat object from the componentStats table, generating a new one if needed
]]
local function getStatEntry(handle)
	local name
	if handle and handle._element and handle._element.component then
		name = tostring(handle._element.component)
	else
		warn("Component name not valid for " .. tostring(handle._key))
		return nil
	end
	local entry = componentStats[name]
	if not entry then
		entry = {
			-- update requests
			updateReqCount = 0,
			-- actual updates
			didUpdateCount = 0,
			-- time spent in shouldUpdate
			shouldUpdateTime = 0,
			-- number of renders
			renderCount = 0,
			-- total render time spent
			renderTime = 0,
		}
		componentStats[name] = entry
	end

	return entry
end

--[[
	Logs the time taken and resulting value of a Component's shouldUpdate function
]]
function Instrumentation.logShouldUpdate(handle, updateNeeded, shouldUpdateTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment the total number of times update was invoked
		statEntry.updateReqCount = statEntry.updateReqCount + 1

		-- Increment (when applicable) total number of times shouldUpdate returned true
		statEntry.didUpdateCount = statEntry.didUpdateCount + (updateNeeded and 1 or 0)

		-- Add time spent checking if an update is needed (in millis) to total time
		statEntry.shouldUpdateTime = statEntry.shouldUpdateTime + shouldUpdateTime * 1000
	end
end

--[[
	Logs the time taken value of a Component's render function
]]
function Instrumentation.logRenderTime(handle, renderTime)
	-- Grab or create associated entry in stats table
	local statEntry = getStatEntry(handle)
	if statEntry then
		-- Increment total render count
		statEntry.renderCount = statEntry.renderCount + 1

		-- Add render time (in millis) to total rendering time
		statEntry.renderTime = statEntry.renderTime + renderTime * 1000
	end
end

--[[
	Clears all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.clearCollectedStats()
	componentStats = {}
end

--[[
	Returns all the stats collected thus far. Useful for testing and for profiling in the future
]]
function Instrumentation.getCollectedStats()
	return componentStats
end

return Instrumentation]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7ABE9F6485A4448FB4C7BBD65EC38F5A">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Config</string>
						<string name="ScriptGuid">{4A81BC5E-8C66-4D2B-A7A4-F1C14CCA9CFB}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables instrumentation of shouldUpdate and render methods for Roact components
	["componentInstrumentation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

--[[
	Merges two tables together into a new table.
]]
local function join(a, b)
	local new = {}

	for key, value in pairs(a) do
		new[key] = value
	end

	for key, value in pairs(b) do
		new[key] = value
	end

	return new
end

local Config = {}

function Config.new()
	local self = {}

	-- Once configuration has been set, we record a traceback.
	-- That way, if the user mistakenly calls `set` twice, we can point to the
	-- first place it was called.
	self._lastConfigTraceback = nil

	self._currentConfig = defaultConfig

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.getValue = function(...)
		return Config.getValue(self, ...)
	end

	self.reset = function(...)
		return Config.reset(self, ...)
	end

	return self
end

function Config.set(self, configValues)
	if self._lastConfigTraceback then
		local message = (
			"Global configuration can only be set once. Configuration was already set at:%s"
		):format(
			self._lastConfigTraceback
		)

		error(message, 3)
	end

	-- We use 3 as our traceback and error level because all of the methods are
	-- manually bound to 'self', which creates an additional stack frame we want
	-- to skip through.
	self._lastConfigTraceback = debug.traceback("", 3)

	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end
	end

	-- Assign all of the (validated) configuration values in one go.
	self._currentConfig = join(self._currentConfig, configValues)
end

function Config.getValue(self, key)
	if defaultConfig[key] == nil then
		local message = (
			"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
		):format(
			tostring(key),
			typeof(key),
			table.concat(defaultConfigKeys, ", ")
		)

		error(message, 3)
	end

	return self._currentConfig[key]
end

function Config.reset(self)
	self._lastConfigTraceback = nil
	self._currentConfig = defaultConfig
end

return Config]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5229CC1D8E684D20BCF5F4A29364F89E">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Event</string>
						<string name="ScriptGuid">{EFB3D471-B46B-48F4-BF8B-60947EC900CB}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Index into 'Event' to get a prop key for attaching to an event on a
	Roblox Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("Event(%s)"):format(self.name)
	end
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			type = Event,
			name = eventName
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end
})

return Event]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBD9752B35C694CD0BC5BC7A5DF06F5B5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">oneChild</string>
						<string name="ScriptGuid">{38C46582-F2DB-4B46-97B8-55E408E38C4B}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Utility to retrieve one child out the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child, but can be passed zero.
]]
local function oneChild(children)
	if not children then
		return
	end

	local key, child = next(children)

	if not child then
		return
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3B958F2CC1334BAEAC1DDBD78D0D1AA4">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">getDefaultPropertyValue</string>
						<string name="ScriptGuid">{600C603D-67D0-453D-8928-C0EACE3A3BDD}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultPropertyValue(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultPropertyValue]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0807E975F8474126A5B01D16EE50B1AB">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Change</string>
						<string name="ScriptGuid">{BABC2422-C66C-4813-93E9-EB01F875E284}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("ChangeListener(%s)"):format(self.name)
	end
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			type = Change,
			name = propertyName
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF3ECE494354049ECAE921A1F201A1EE2">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">invalidSetStateMessages</string>
						<string name="ScriptGuid">{C1E9B76E-0E5B-46F6-B96E-65DC0BDFA43C}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]

local invalidSetStateMessages = {}

invalidSetStateMessages["willUpdate"] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages["willUnmount"] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages["shouldUpdate"] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages["init"] = [[
setState cannot be used in the init method.
During init, the component hasn't initialized yet, and isn't ready to render.

Instead, set the `state` value directly:

	self.state = {
		value = "foo"
	}

Check the definition of init in the component %q.]]

invalidSetStateMessages["render"] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["reconcile"] = [[
setState cannot be called while a component is being reified or reconciled.
This is the step where Roact constructs Roblox instances, and starting another
render here would introduce bugs.

Check the component %q to see if setState is being called by:
* a child Ref
* a child Changed event
* a child's render method]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, but Roact couldn't find a
message to display.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0813C8629553450CB362B89A9D149817">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Reconciler</string>
						<string name="ScriptGuid">{8002A104-79F8-413C-9937-DEB1F20E3CF4}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	The reconciler uses the virtual DOM generated by components to create a real
	tree of Roblox instances.

	The reonciler has three basic operations:
	* mount (previously reify)
	* reconcile
	* unmount (previously teardown)

	Mounting is the process of creating new components. This is first
	triggered when the user calls `Roact.mount` on an element. This is where the
	structure of the component tree is built, later used and modified by the
	reconciliation and unmounting steps.

	Reconciliation accepts an existing concrete instance tree (created by mount)
	along with a new element that describes the desired tree. The reconciler
	will do the minimum amount of work required to update tree's components to
	match the new element, sometimes invoking mount to create new branches.

	Unmounting destructs for the tree. It will crawl through the tree,
	destroying nodes from the bottom up.

	Much of the reconciler's work is done by Component, which is the base for
	all stateful components in Roact. Components can trigger reconciliation (and
	implicitly, unmounting) via state updates that come with their own caveats.
]]

local Core = require(script.Parent.Core)
local Event = require(script.Parent.Event)
local Change = require(script.Parent.Change)
local getDefaultPropertyValue = require(script.Parent.getDefaultPropertyValue)
local SingleEventManager = require(script.Parent.SingleEventManager)
local Symbol = require(script.Parent.Symbol)

local isInstanceHandle = Symbol.named("isInstanceHandle")

local DEFAULT_SOURCE = "\n\t<Use Roact.setGlobalConfig with the 'elementTracing' key to enable detailed tracebacks>\n"

local function isPortal(element)
	if type(element) ~= "table" then
		return false
	end

	return element.component == Core.Portal
end

--[[
	Sets the value of a reference to a new rendered object.
	Correctly handles both function-style and object-style refs.
]]
local function applyRef(ref, newRbx)
	if ref == nil then
		return
	end

	if type(ref) == "table" then
		ref.current = newRbx
	else
		ref(newRbx)
	end
end

local Reconciler = {}

Reconciler._singleEventManager = SingleEventManager.new()

--[[
	Is this element backed by a Roblox instance directly?
]]
local function isPrimitiveElement(element)
	if type(element) ~= "table" then
		return false
	end

	return type(element.component) == "string"
end

--[[
	Is this element defined by a pure function?
]]
local function isFunctionalElement(element)
	if type(element) ~= "table" then
		return false
	end

	return type(element.component) == "function"
end

--[[
	Is this element defined by a component class?
]]
local function isStatefulElement(element)
	if type(element) ~= "table" then
		return false
	end

	return type(element.component) == "table"
end

--[[
	Destroy the given Roact instance, all of its descendants, and associated
	Roblox instances owned by the components.
]]
function Reconciler.unmount(instanceHandle)
	local element = instanceHandle._element

	if isPrimitiveElement(element) then
		-- We're destroying a Roblox Instance-based object

		-- Kill refs before we make changes, since any mutations past this point
		-- aren't relevant to components.
		applyRef(element.props[Core.Ref], nil)

		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end

		-- Necessary to make sure SingleEventManager doesn't leak references
		Reconciler._singleEventManager:disconnectAll(instanceHandle._rbx)

		instanceHandle._rbx:Destroy()
	elseif isFunctionalElement(element) then
		-- Functional components can return nil
		if instanceHandle._child then
			Reconciler.unmount(instanceHandle._child)
		end
	elseif isStatefulElement(element) then
		instanceHandle._instance:_unmount()
	elseif isPortal(element) then
		for _, child in pairs(instanceHandle._children) do
			Reconciler.unmount(child)
		end
	else
		error(("Cannot unmount invalid Roact instance %q"):format(tostring(element)))
	end
end

--[[
	Public interface to reifier. Hides parameters used when recursing down the
	component tree.
]]
function Reconciler.mount(element, parent, key)
	return Reconciler._mountInternal(element, parent, key)
end

--[[
	Instantiates components to represent the given element.

	Parameters:
		- `element`: The element to mount.
		- `parent`: The Roblox object to contain the contained instances
		- `key`: The Name to give the Roblox instance that gets created
		- `context`: Used to pass Roact context values down the tree

	The structure created by this method is important to the functionality of
	the reconciliation methods; they depend on this structure being well-formed.
]]
function Reconciler._mountInternal(element, parent, key, context)
	if isPrimitiveElement(element) then
		-- Primitive elements are backed directly by Roblox Instances.

		local rbx = Instance.new(element.component)

		-- Update Roblox properties
		for key, value in pairs(element.props) do
			Reconciler._setRbxProp(rbx, key, value, element)
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, rbx, key, context)

				children[key] = childInstance
			end
		end

		-- This name can be passed through multiple components.
		-- Elements with the same key will be treated as the same
		-- element between reconciles; the old element will be
		-- reconciled to the new element with the same key.
		if key then
			rbx.Name = key
		end

		rbx.Parent = parent

		-- Attach ref values, since the instance is initialized now.
		applyRef(element.props[Core.Ref], rbx)

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = rbx,
		}
	elseif isFunctionalElement(element) then
		-- Functional elements contain 0 or 1 children.

		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
		}

		local vdom = element.component(element.props)
		if vdom then
			instanceHandle._child = Reconciler._mountInternal(vdom, parent, key, context)
		end

		return instanceHandle
	elseif isStatefulElement(element) then
		-- Stateful elements have 0 or 1 children, and also have a backing
		-- instance that can keep state.

		-- We separate the instance's implementation from our handle to it.
		local instanceHandle = {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_child = nil,
		}

		local instance = element.component._new(element.props, context)

		instanceHandle._instance = instance
		instance:_mount(instanceHandle)

		return instanceHandle
	elseif isPortal(element) then
		-- Portal elements have one or more children.

		local target = element.props.target
		if not target then
			error(("Cannot mount Portal without specifying a target."):format(tostring(element)))
		elseif typeof(target) ~= "Instance" then
			error(("Cannot mount Portal with target of type %q."):format(typeof(target)))
		end

		-- Create children!
		local children = {}

		if element.props[Core.Children] then
			for key, childElement in pairs(element.props[Core.Children]) do
				local childInstance = Reconciler._mountInternal(childElement, target, key, context)

				children[key] = childInstance
			end
		end

		return {
			[isInstanceHandle] = true,
			_key = key,
			_parent = parent,
			_element = element,
			_context = context,
			_children = children,
			_rbx = target,
		}
	elseif typeof(element) == "boolean" then
		-- Ignore booleans of either value
		-- See https://github.com/Roblox/roact/issues/14
		return nil
	end

	error(("Cannot mount invalid Roact element %q"):format(tostring(element)))
end

--[[
	A public interface around _reconcileInternal
]]
function Reconciler.reconcile(instanceHandle, newElement)
	if instanceHandle == nil or not instanceHandle[isInstanceHandle] then
		local message = (
			"Bad argument #1 to Reconciler.reconcile, expected component instance handle, found %s"
		):format(
			typeof(instanceHandle)
		)

		error(message, 2)
	end

	return Reconciler._reconcileInternal(instanceHandle, newElement)
end

--[[
	Applies the state given by newElement to an existing Roact instance.

	reconcile will return the instance that should be used. This instance can
	be different than the one that was passed in.
]]
function Reconciler._reconcileInternal(instanceHandle, newElement)
	local oldElement = instanceHandle._element

	-- Instance was deleted!
	if not newElement then
		Reconciler.unmount(instanceHandle)

		return nil
	end

	-- If the element changes type, we assume its subtree will be substantially
	-- different. This lets us skip comparisons of a large swath of nodes.
	if oldElement.component ~= newElement.component then
		local parent = instanceHandle._parent
		local key = instanceHandle._key

		local context
		if isStatefulElement(oldElement) then
			context = instanceHandle._instance._context
		else
			context = instanceHandle._context
		end

		Reconciler.unmount(instanceHandle)

		local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

		return newInstance
	end

	if isPrimitiveElement(newElement) then
		-- Roblox Instance change

		local oldRef = oldElement.props[Core.Ref]
		local newRef = newElement.props[Core.Ref]

		-- Change the ref in one pass before applying any changes.
		-- Roact doesn't provide any guarantees with regards to the sequencing
		-- between refs and other changes in the commit phase.
		if newRef ~= oldRef then
			applyRef(oldRef, nil)
			applyRef(newRef, instanceHandle._rbx)
		end

		-- Update properties and children of the Roblox object.
		Reconciler._reconcilePrimitiveProps(oldElement, newElement, instanceHandle._rbx)
		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	elseif isFunctionalElement(newElement) then
		instanceHandle._element = newElement

		local rendered = newElement.component(newElement.props)
		local newChild

		if instanceHandle._child then
			-- Transition from tree to tree, even if 'rendered' is nil
			newChild = Reconciler._reconcileInternal(instanceHandle._child, rendered)
		elseif rendered then
			-- Transition from nil to new tree
			newChild = Reconciler._mountInternal(
				rendered,
				instanceHandle._parent,
				instanceHandle._key,
				instanceHandle._context
			)
		end

		instanceHandle._child = newChild

		return instanceHandle
	elseif isStatefulElement(newElement) then
		instanceHandle._element = newElement

		-- Stateful elements can take care of themselves.
		instanceHandle._instance:_update(newElement.props)

		return instanceHandle
	elseif isPortal(newElement) then
		if instanceHandle._rbx ~= newElement.props.target then
			local parent = instanceHandle._parent
			local key = instanceHandle._key
			local context = instanceHandle._context

			Reconciler.unmount(instanceHandle)

			local newInstance = Reconciler._mountInternal(newElement, parent, key, context)

			return newInstance
		end

		Reconciler._reconcilePrimitiveChildren(instanceHandle, newElement)

		instanceHandle._element = newElement

		return instanceHandle
	end

	error(("Cannot reconcile to match invalid Roact element %q"):format(tostring(newElement)))
end

--[[
	Reconciles the children of an existing Roact instance and the given element.
]]
function Reconciler._reconcilePrimitiveChildren(instance, newElement)
	local elementChildren = newElement.props[Core.Children]

	-- Reconcile existing children that were changed or removed
	for key, childInstance in pairs(instance._children) do
		local childElement = elementChildren and elementChildren[key]

		childInstance = Reconciler._reconcileInternal(childInstance, childElement)

		instance._children[key] = childInstance
	end

	-- Create children that were just added!
	if elementChildren then
		for key, childElement in pairs(elementChildren) do
			-- Update if we didn't hit the child in the previous loop
			if not instance._children[key] then
				local childInstance = Reconciler._mountInternal(childElement, instance._rbx, key, instance._context)
				instance._children[key] = childInstance
			end
		end
	end
end

--[[
	Reconciles the properties between two primitive Roact elements and applies
	the differences to the given Roblox object.
]]
function Reconciler._reconcilePrimitiveProps(fromElement, toElement, rbx)
	local seenProps = {}

	-- Set properties that were set with fromElement
	for key, oldValue in pairs(fromElement.props) do
		seenProps[key] = true

		local newValue = toElement.props[key]

		-- Assume any property that can be set to nil has a default value of nil
		if newValue == nil then
			local _, value = getDefaultPropertyValue(rbx.ClassName, key)

			-- We don't care if getDefaultPropertyValue fails, because
			-- _setRbxProp will catch the error below.
			newValue = value
		end

		-- Roblox does this check for normal values, but we have special
		-- properties like events that warrant this.
		if oldValue ~= newValue then
			Reconciler._setRbxProp(rbx, key, newValue, toElement)
		end
	end

	-- Set properties that are new in toElement
	for key, newValue in pairs(toElement.props) do
		if not seenProps[key] then
			seenProps[key] = true

			local oldValue = fromElement.props[key]

			if oldValue ~= newValue then
				Reconciler._setRbxProp(rbx, key, newValue, toElement)
			end
		end
	end
end

--[[
	Used in _setRbxProp to avoid creating a new closure for every property set.
]]
local function set(rbx, key, value)
	rbx[key] = value
end

--[[
	Sets a property on a Roblox object, following Roact's rules for special
	case properties.

	This function can throw a couple different errors. In the future, calls to
	_setRbxProp should be wrapped in a pcall to give better errors to the user.

	For that to be useful, we'll need to attach a 'source' property on every
	element, created using debug.traceback(), that points to where the element
	was created.
]]
function Reconciler._setRbxProp(rbx, key, value, element)
	if type(key) == "string" then
		-- Regular property

		local success, err = pcall(set, rbx, key, value)

		if not success then
			local source = element.source or DEFAULT_SOURCE

			local message = ("Failed to set property %s on primitive instance of class %s\n%s\n%s"):format(
				key,
				rbx.ClassName,
				err,
				source
			)

			error(message, 0)
		end
	elseif type(key) == "table" then
		-- Special property with extra data attached.

		if key.type == Event then
			Reconciler._singleEventManager:connect(rbx, key.name, value)
		elseif key.type == Change then
			Reconciler._singleEventManager:connectProperty(rbx, key.name, value)
		else
			local source = element.source or DEFAULT_SOURCE

			-- luacheck: ignore 6
			local message = ("Failed to set special property on primitive instance of class %s\nInvalid special property type %q\n%s"):format(
				rbx.ClassName,
				tostring(key.type),
				source
			)

			error(message, 0)
		end
	elseif type(key) ~= "userdata" then
		-- Userdata values are special markers, usually created by Symbol
		-- They have no data attached other than being unique keys

		local source = element.source or DEFAULT_SOURCE

		local message = ("Properties with a key type of %q are not supported\n%s"):format(
			type(key),
			source
		)

		error(message, 0)
	end
end

return Reconciler
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX28E9E1271A074A87B06F3227C2C2F324">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ReconcilerCompat</string>
						<string name="ScriptGuid">{3EF29A66-3EA8-47F9-9945-9C70B6C0FAA8}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Reconciler = require(script.Parent.Reconciler)

local warnedLocations = {}

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local ReconcilerCompat = {}

--[[
	Exposed as a method so that test cases can override `warn`.
]]
ReconcilerCompat._warn = warn

local function warnOnce(message)
	local trace = debug.traceback(message, 3)
	if warnedLocations[trace] then
		return
	end

	warnedLocations[trace] = true

	ReconcilerCompat._warn(trace)
end

function ReconcilerCompat.reify(...)
	warnOnce(reifyMessage)

	return Reconciler.mount(...)
end

function ReconcilerCompat.teardown(...)
	warnOnce(teardownMessage)

	return Reconciler.unmount(...)
end

return ReconcilerCompat]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX44E152096DFC45E4867D0C3F30176CFC">
				<Properties>
					<string name="Name">ExtraLibs</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXF4EF7E10D3864FCCA111FDD58DF60150">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AssetTextbox</string>
						<string name="ScriptGuid">{B1248BE4-BC05-41C4-BC04-65ABF0F195C9}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local AssetTextbox = Roact.Component:extend("AssetTextbox")

function AssetTextbox:init(initialProps)
	local value = initialProps.value
	if self.props.guard then
		value = self.props.guard(value)
	end
	self.state = {
		value = value;
	}
end

local function getAssetLink(id)
	local success, info = pcall(function() return game:GetService("MarketplaceService"):GetProductInfo(id) end)
	if success then
		if info.AssetTypeId ~= Enum.AssetType.Decal.Value then
			return "rbxassetid://"..id
		else
			local success, data = pcall(function() return game:GetObjects("rbxassetid://"..id)[1].Texture end)
			if success then
				local asset = data:gsub("http://www.roblox.com/asset/%?id=", "rbxassetid://")
				return asset
			end
		end
	end
	return ""
end

function AssetTextbox:parse(str)
	local match = tonumber(str)
		or str:match("rbxassetid://(%d+)")
		or str:match(".*www.roblox.com/asset/%?id=(%d+)")
		or str:match(".*www.roblox.com/library/(%d+)/.*")
	if tonumber(match) then
		return getAssetLink(tonumber(match))
	end
	return ""
end

function AssetTextbox:tostring()
	return self.state.value or ""
end

function AssetTextbox:render()
	
	local function onComplete(str)
		local value = self:parse(str)
		self:setState({focused = false, value = value or self.state.value})
		if self.props.setValue then
			self.props.setValue(self.state.value)
		end
	end
	
	return Roact.createElement(Libs.Textbox, {
		LayoutOrder = self.props.LayoutOrder;
		Size = self.props.Size;
		
		focused = self.state.focused;
		value = self.focused and "" or self:tostring();
		focusLost = onComplete;
		onSubmit = onComplete;
		ClearTextOnFocus = self.props.ClearTextOnFocus;
		onFocused = function()
			self:setState({focused = true})
		end
	})
	
end

return AssetTextbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8DE71DC2E495458F9EECB4870B98D678">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ColorTextbox</string>
						<string name="ScriptGuid">{9C40D06F-0C8A-42D2-AF3D-F1CFFD536897}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local VectorTextbox = require(script.Parent.VectorTextbox)

local ColorTextbox = Roact.Component:extend("ColorTextbox")

function ColorTextbox:init(initialProps)
	local value = initialProps.value
	self.state = {
		value = value;
	}
end

function ColorTextbox:render()
	
	return Roact.createElement("Frame", {
		Size = self.props.Size;
		Position = self.props.Position;
		BackgroundTransparency = 1;
	}, {
		Color = Roact.createElement("Frame", {
			Position = UDim2.new(0,4,.5,0),
			Size = UDim2.new(0,10,0,10),
			AnchorPoint = Vector2.new(0,.5),
			BorderColor3 = Color3.new(0,0,0),
			BackgroundColor3 = Color3.fromRGB(self.state.value.x, self.state.value.y, self.state.value.z)
		});
		Value = Roact.createElement(VectorTextbox, {
			Size = UDim2.new(1,-18,1,0);
			Position = UDim2.new(0,18,0,0);
			ClearTextOnFocus = self.props.ClearTextOnFocus;
			value = self.state.value;
			guard = function(vec)
				return Vector3.new(
					math.floor(.5 + math.clamp(vec.x, 0, 255)),
					math.floor(.5 + math.clamp(vec.y, 0, 255)),
					math.floor(.5 + math.clamp(vec.z, 0, 255))
				)
			end;
			setValue = function(t)
				self:setState({value = t})
				if self.props.setValue then
					self.props.setValue(t)
				end
			end;
		});
	});
	
end

return ColorTextbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE7211EA01F274A3F85D076CCE7750FDC">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatefulRadioButtons</string>
						<string name="ScriptGuid">{B23BB8CC-A577-4A27-9E27-18B35166B44D}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local StatefulRadioButtons = Roact.Component:extend("StatefulRadioButtons")

function StatefulRadioButtons:init(initialProps)
	self.state = {
		LayoutOrder = initialProps.LayoutOrder or 1;
		buttonSize = initialProps.buttonSize;
		size = initialProps.size;
		selected = initialProps.selected or 1;
		buttons = initialProps.buttons;
	}
end

function StatefulRadioButtons:render()
	return Roact.createElement(Libs.RadioButtons, {
		LayoutOrder = self.state.LayoutOrder;
		buttonSize = self.state.buttonSize;
		size = self.state.size;
		selected = self.state.selected;
		buttons = self.state.buttons;
		onSelect = function(i, button)
			self:setState({selected = i;})
			if self.props.onSelect then
				self.props.onSelect(i, button)
			end
		end
	})
end

return StatefulRadioButtons]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80430B96A4C24F9198CF613FEAA8D815">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">init</string>
						<string name="ScriptGuid">{17D93A7E-C37E-4CEF-BEAE-A103A26403D0}</string>
						<ProtectedString name="Source"><![CDATA[local modules = {}

for _,module in pairs(script.Parent:GetChildren()) do
	if module ~= script and module:IsA("ModuleScript") then
		modules[module.Name] = require(module)
	end
end

return modules
]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXAD389BC6C24B4749925E3CE54E94A4D8">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LabeledSlider</string>
						<string name="ScriptGuid">{2548284A-781C-44DB-BD27-FBAED208056D}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local LabeledSlider = Roact.Component:extend("LabeledSlider")

function LabeledSlider:init(initialProps)
	self.state = {
		value = initialProps.value;
	}
end

local function Round(n, r)
	if not r then r = 1 end
	return math.floor((n / r) + 0.5) * r
end

local function getNumPattern(n)
	local pattern = (n == math.floor(n)) and "%d" or "%.3f"
	return pattern:format(n)
end

function LabeledSlider:render()
	
	local function onComplete(str)
		local clampNum = tonumber(str) or self.state.value
		local clampMin = self.props.sliderMin or 0
		local clampMax
		if self.props.sliderMax and self.props.sliderMin then
			clampMax = self.props.sliderMax + self.props.sliderMin
		elseif self.props.sliderMax then
			clampMax = self.props.sliderMax
		else
			clampMax = 1
		end
		local value
		if not self.props.unrestricted then
			value = Round(math.clamp(clampNum, clampMin, clampMax), self.props.sliderSnap)
		else
			value = Round(clampNum, self.props.sliderSnap)
		end
		self:setState({focused = false, value = value})
		if self.props.setValue then
			self.props.setValue(self.state.value)
		end
	end
	
	return Roact.createElement("Frame", {
		Size = UDim2.new(1,0,1,0),
		BackgroundTransparency = 1,
	}, {
		Box = Roact.createElement(Libs.Textbox, {
			Size = UDim2.new(0, 36, 1, 0),
			focused = self.state.focused;
			value = getNumPattern(self.state.value);
			focusLost = onComplete;
			onSubmit = onComplete;
			ClearTextOnFocus = true;
			onFocused = function()
				self:setState({focused = true})
			end
		}),
		Slider = Roact.createElement(Libs.Slider, {
			LayoutOrder = self.props.LayoutOrder;
			Size = self.props.Size - UDim2.new(0,40,0,0);
			Position = UDim2.new(0,40,0,0),
			sliderMax = self.props.sliderMax or 1,
			sliderMin = self.props.sliderMin or 0,
			sliderSnap = self.props.sliderSnap or 0.001,
			value = self.state.value;
			setValue = function(v)
				self:setState({value = v})
				if self.props.setValue then
					self.props.setValue(v)
				end
			end
		})
	})
end

return LabeledSlider]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC9F29C22A94548CEB5C0CC8CF4C17881">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatefulCheckbox</string>
						<string name="ScriptGuid">{5E0F712B-CDA6-4827-BEC2-7A451841714E}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local StatefulCheckbox = Roact.Component:extend("StatefulCheckbox")

function StatefulCheckbox:init(initialProps)
	self.state = {
		value = initialProps.value;
	}
end

function StatefulCheckbox:render()
	return Roact.createElement(Libs.Checkbox, {
		LayoutOrder = self.props.LayoutOrder;
		Size = self.props.Size;
		value = self.state.value;
		setValue = function(v)
			self:setState({value = v})
			if self.props.setValue then
				self.props.setValue(v)
			end
		end
	})
end

return StatefulCheckbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF30B427C31A847D9A1804DF9FAD1F045">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StatefulRadioListButtons</string>
						<string name="ScriptGuid">{72511DF6-1394-480E-9D3A-B944E3F86844}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local StatefulRadioListButtons = Roact.Component:extend("StatefulRadioListButtons")

function StatefulRadioListButtons:init(initialProps)
	self.state = {
		LayoutOrder = initialProps.LayoutOrder or 1;
		buttonSize = initialProps.buttonSize;
		size = initialProps.size;
		selected = initialProps.selected or 1;
		buttons = initialProps.buttons;
	}
end

function StatefulRadioListButtons:render()
	return Roact.createElement(Libs.RadioListButtons, {
		LayoutOrder = self.state.LayoutOrder;
		buttonSize = self.state.buttonSize;
		size = self.state.size;
		selected = self.state.selected;
		buttons = self.state.buttons;
		onSelect = function(i, button)
			self:setState({selected = i;})
			if self.props.onSelect then
				self.props.onSelect(i, button)
			end
		end
	})
end

return StatefulRadioListButtons]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXF159C81FF691467BA7E4CBDB7574093D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VectorTextbox</string>
						<string name="ScriptGuid">{B654F916-2082-4D02-B4F3-629D517AD06D}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)

local VectorTextbox = Roact.Component:extend("VectorTextbox")

function VectorTextbox:init(initialProps)
	local value = initialProps.value
	if self.props.guard then
		value = self.props.guard(value)
	end
	self.state = {
		value = value;
	}
end

function VectorTextbox:parse(str)
	local x,y,z = str:match("^%[?%s*(.-)%s*,%s*(.-)%s*,%s*(.-)%s*%]?$")
	x = tonumber(x)
	y = tonumber(y)
	z = tonumber(z)
	if x and y and z then
		local value = Vector3.new(x,y,z)
		if self.props.guard then
			value = self.props.guard(value)
		end
		return value
	end
end

local function getNumPattern(n)
	local pattern = (n == math.floor(n)) and "%d" or "%.3f"
	return pattern:format(n)
end

function VectorTextbox:tostring()
	return ("[%s, %s, %s]"):format(
		getNumPattern(self.state.value.x),
		getNumPattern(self.state.value.y),
		getNumPattern(self.state.value.z)
	)
end

function VectorTextbox:render()
	
	local function onComplete(str)
		local value = self:parse(str)
		self:setState({focused = false, value = value or self.state.value})
		if self.props.setValue then
			self.props.setValue(self.state.value)
		end
	end
	
	return Roact.createElement(Libs.Textbox, {
		LayoutOrder = self.props.LayoutOrder;
		Size = self.props.Size;
		Position = self.props.Position;
		
		focused = self.state.focused;
		value = self:tostring();
		focusLost = onComplete;
		onSubmit = onComplete;
		ClearTextOnFocus = self.props.ClearTextOnFocus;
		onFocused = function()
			self:setState({focused = true})
		end
	})
	
end

return VectorTextbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6AF5BD94D30543A797E645068D936207">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MaterialTextbox</string>
						<string name="ScriptGuid">{2B404C79-6F90-4569-A9AC-DC55FC4534C7}</string>
						<ProtectedString name="Source"><![CDATA[local Roact = require(script.Parent.Parent.Roact)
local Libs = require(script.Parent.Parent.Libs.init)
local Materials = require(script.Parent.Parent.Parent.Modules:WaitForChild("Materials"))

local MaterialTextbox = Roact.Component:extend("MaterialTextbox")

function MaterialTextbox:init(initialProps)
	local value = initialProps.value
	if self.props.guard then
		value = self.props.guard(value)
	end
	self.state = {
		value = value;
	}
end

function MaterialTextbox:parse(str)
	local material = str:sub(1,1):upper() .. str:sub(2):lower()
	
	if Materials[material] then
		local value = material
		if self.props.guard then
			value = self.props.guard(value)
		end
		return value
	end
end

function MaterialTextbox:render()
	
	local function onComplete(str)
		local value = self:parse(str)
		self:setState({focused = false, value = value or self.state.value})
		if self.props.setValue then
			self.props.setValue(self.state.value)
		end
	end
	
	return Roact.createElement(Libs.Textbox, {
		LayoutOrder = self.props.LayoutOrder;
		Size = self.props.Size;
		Position = self.props.Position;
		
		focused = self.state.focused;
		value = self.state.value;
		focusLost = onComplete;
		onSubmit = onComplete;
		ClearTextOnFocus = self.props.ClearTextOnFocus;
		onFocused = function()
			self:setState({focused = true})
		end
	})
	
end

return MaterialTextbox]]></ProtectedString>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX59F918D39A064983A1EDBE5A70120538">
			<Properties>
				<string name="Name">Events</string>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="BindableEvent" referent="RBX07296BBBB5884996AC4B3B52891F94DC">
				<Properties>
					<string name="Name">GeneratorStateEvent</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="BindableEvent" referent="RBX86F58DD0B8BC434BBD5A1E7B64E2997B">
				<Properties>
					<string name="Name">CancelEvent</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="BindableEvent" referent="RBXFDF36797CAB746D69A336A4835F66085">
				<Properties>
					<string name="Name">ResetToDefault</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="BindableEvent" referent="RBX8D0808BC89614F07B0D8336CBC2650B0">
				<Properties>
					<string name="Name">ImporterStateEvent</string>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX9A0269FFE6DA428A9F4401D0A35AD30A">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Main</string>
				<string name="ScriptGuid">{6193C5CB-A704-49F3-B654-2EB363235EB7}</string>
				<ProtectedString name="Source"><![CDATA[--// Modules
local m = script.Parent:WaitForChild("Modules")

local Roact = require(script.Parent:WaitForChild("Roact"):WaitForChild("Roact"))
local GeneratorApp = require(m:WaitForChild("GeneratorApp"))
local ImporterApp = require(m:WaitForChild("ImporterApp"))

local Materials = require(m:WaitForChild("Materials"))
local Visualizer = require(m:WaitForChild("Visualizer"))


--// Misc
local GeneratorStateEvent = script.Parent:WaitForChild("Events"):WaitForChild("GeneratorStateEvent")
local ImporterStateEvent = script.Parent:WaitForChild("Events"):WaitForChild("ImporterStateEvent")


--// Settings
local PLUGIN_NAME = "Heightmaster"

local GENERATOR_NAME = "Heightmaster_Generator"
local GENERATOR_DISPLAY_NAME = "Generator"
local GENERATOR_DESCRIPTION = "Generate terrain from heightmap"
local GENERATOR_IMAGE = "rbxassetid://2768575443"

local IMPORTER_NAME = "Heightmaster_Importer"
local IMPORTER_DISPLAY_NAME = "Importer"
local IMPORTER_DESCRIPTION = "Import heightmaps and texturemaps for use within the Heightmaster generator"
local IMPORTER_IMAGE = "rbxassetid://2803496911"

local IMPORTER_ENABLED = false;


--// Plugin Setup
plugin.Name = PLUGIN_NAME

local toolbar = plugin:CreateToolbar(PLUGIN_NAME)

local generatorPluginInfo, generatorPluginGui, generatorButton
local importerPluginInfo, importerPluginGui, importerButton

-- Generator
do
	generatorPluginInfo = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Float, false, false, 338, 500, 338, 125)
	generatorPluginGui = plugin:CreateDockWidgetPluginGui(GENERATOR_NAME, generatorPluginInfo)
	generatorPluginGui.Name = GENERATOR_NAME
	generatorPluginGui.Title = GENERATOR_DISPLAY_NAME
	generatorPluginGui.Enabled = false
	
	generatorButton = toolbar:CreateButton(GENERATOR_DISPLAY_NAME, GENERATOR_DESCRIPTION, GENERATOR_IMAGE)
	generatorButton.ClickableWhenViewportHidden = false
end

-- Importer
do
	local localAssetFlagExists, localAssetFlagEnabled = pcall(function()
		return settings():GetFFlag("StudioLocalAssetsEnabled")
	end)
	if localAssetFlagExists and localAssetFlagEnabled and IMPORTER_ENABLED then
		importerPluginInfo = DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Float, false, false, 500, 300, 500, 300)
		importerPluginGui = plugin:CreateDockWidgetPluginGui(IMPORTER_NAME, importerPluginInfo)
		importerPluginGui.Name = IMPORTER_NAME
		importerPluginGui.Title = IMPORTER_DISPLAY_NAME
		importerPluginGui.Enabled = false
		
		importerButton = toolbar:CreateButton(IMPORTER_DISPLAY_NAME, IMPORTER_DESCRIPTION, IMPORTER_IMAGE)
		importerButton.ClickableWhenViewportHidden = false
	end
end

-- States
local importerState = {
	Heightmap = nil;
	HeightmapImageId = "";
	HeightmapLoaded = false;
	
	Texturemap = nil;
	TexturemapImageId = "";
	TexturemapLoaded = false;
}

local function getAllowedMaterials()
	local mats = {}
	for i,v in pairs(Materials) do
		mats[i] = v.defaultValue
	end
	return mats
end


local function getCustomColors()
	local cols = {}
	for i,v in pairs(Materials) do
		local col = v.colour
		cols[i] = Vector3.new(col.r * 255, col.g * 255, col.b * 255)
	end
	return cols
end

local generatorDefaultState = {
	Terrain = {
		TerrainScale = 50;
		TerrainOrigin = Vector3.new(0, 0, 0);
		RemoveExcessTerrain = false;
		SmoothDepth = 2;
		RemoveLevelZero = false;
		InvertTerrain = false;
		OptimizeTerrain = true;
		RemoveExcessTerrain = true;
	};
	Materials = {
		MaterialMode = 2;
		DefaultMaterial = "Grass";
	};
	AllowedMaterials = getAllowedMaterials();
	Subsurface = {
		UseSubsurfaceMaterial = true;
		SubsurfaceMaterial = "Rock";
		SubsurfaceHeight = 0.75;
	};
	Water = {
		EnableWater = true;
		WaterHeight = 15;
		WaterOccupancy = 1;
		WaterSize = 1;
		UseSubWaterMaterial = false;
		SubWaterMaterial = "Sand";
		GenerateSeabed = true;
		SeabedDepth = 2;
	};
	Beach = {
		EnableBeach = false;
		BeachHeight = 2;
		BeachDepth = 4;
		BeachMaterial = "Sand";
	};
	CustomColors = getCustomColors();
}
local generatorState = generatorDefaultState


--// Code

-- Generator
local generatorHandle

local function reloadGenerator(newState)
	Roact.unmount(generatorHandle)
	generatorHandle = Roact.mount(GeneratorApp(newState), generatorPluginGui)
end

generatorButton.Click:Connect(function()
	if generatorPluginGui.Enabled then
		generatorPluginGui.Enabled = false
	else
		generatorHandle = Roact.mount(GeneratorApp(generatorState), generatorPluginGui)
		--reloadGenerator(generatorState)
		generatorPluginGui.Enabled = true
	end
end)

local function generatorToggle()
	if generatorPluginGui.Enabled then
		generatorButton:SetActive(true)
	else
		if generatorHandle then
			Roact.unmount(generatorHandle)
			generatorHandle = nil
		end
		generatorButton:SetActive(false)
		Visualizer:Clear()
	end
end
generatorToggle()

generatorPluginGui:GetPropertyChangedSignal("Enabled"):Connect(function()
	generatorToggle()
end)

GeneratorStateEvent.Event:Connect(function(newState)
	generatorState = newState
end)


-- Importer
if importerPluginInfo and importerPluginGui and importerButton and IMPORTER_ENABLED then
	local importerHandle
	
	local function reloadImporter(newState)
		Roact.unmount(importerHandle)
		importerHandle = Roact.mount(ImporterApp(newState), importerPluginGui)
	end
	
	importerButton.Click:Connect(function()
		if importerPluginGui.Enabled then
			importerPluginGui.Enabled = false
		else
			importerHandle = Roact.mount(ImporterApp(importerState), importerPluginGui)
			--reloadImporter(importerState)
			importerPluginGui.Enabled = true
		end
	end)
	
	local function importerToggle()
		if importerPluginGui.Enabled then
			importerButton:SetActive(true)
		else
			if importerHandle then
				Roact.unmount(importerHandle)
				importerHandle =nil
			end
			importerButton:SetActive(false)
		end	
	end
	importerToggle()
	
	importerPluginGui:GetPropertyChangedSignal("Enabled"):Connect(function()
		importerToggle()
	end)
	
	ImporterStateEvent.Event:Connect(function(newState)
		importerState = newState
		reloadImporter(newState)
	end)
end]]></ProtectedString>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>